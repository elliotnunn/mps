;
;	File:		Windows.a
;
;	Contains:	Window Manager Interfaces.
;
;	Version:	Technology:	System 7.5
;				Package:	Universal Interfaces 2.2.5
;
;	Copyright:	© 1984-1997 by Apple Computer, Inc.
;				All rights reserved.
;
;	Bugs?:		If you find a problem with this file, use the Apple Bug Reporter
;				stack.  Include the file and version information (from above)
;				in the problem description and send to:
;					Internet:	apple.bugs@applelink.apple.com
;					AppleLink:	APPLE.BUGS
;
;

	IF &TYPE('__WINDOWS__') = 'UNDEFINED' THEN
__WINDOWS__ SET 1


	IF &TYPE('__TYPES__') = 'UNDEFINED' THEN
	include 'Types.a'
	ENDIF
;		include 'ConditionalMacros.a'								;

	IF &TYPE('__MEMORY__') = 'UNDEFINED' THEN
	include 'Memory.a'
	ENDIF
;		include 'MixedMode.a'										;

	IF &TYPE('__QUICKDRAW__') = 'UNDEFINED' THEN
	include 'Quickdraw.a'
	ENDIF
;		include 'QuickdrawText.a'									;

	IF &TYPE('__EVENTS__') = 'UNDEFINED' THEN
	include 'Events.a'
	ENDIF
;		include 'OSUtils.a'										;

	IF &TYPE('__CONTROLS__') = 'UNDEFINED' THEN
	include 'Controls.a'
	ENDIF
;		include 'Menus.a'											;

;   *****************************************************************************
;   *                                                                           *
;   * The conditional STRICT_WINDOWS has been removed from this interface file. *
;   * The accessor macros to a WindowRecord are no longer necessary.            *
;   *                                                                           *
;   * All ≈Ref Types have reverted to their original Handle and Ptr Types.      *
;   *                                                                           *
;   *****************************************************************************
;   
;   Details:
;   The original purpose of the STRICT_ conditionals and accessor macros was to
;   help ease the transition to Copland.  Shared data structures are difficult
;   to coordinate in a preemptive multitasking OS.  By hiding the fields in a
;   WindowRecord and other data structures, we would begin the migration to the
;   discipline wherein system data structures are completely hidden from
;   applications.
;   
;   After many design reviews, we finally concluded that with this sort of
;   migration, the system could never tell when an application was no longer
;   peeking at a WindowRecord, and thus the data structure might never become
;   system owned.  Additionally, there were many other limitations in the
;   classic toolbox that were begging to be addressed.  The final decision was
;   to leave the traditional toolbox as a compatibility mode.
;   
;   We also decided to use the Handle and Ptr based types in the function
;   declarations.  For example, NewWindow now returns a WindowPtr rather than a
;   WindowRef.  The Ref types are still defined in the header files, so all
;   existing code will still compile exactly as it did before.  There are
;   several reasons why we chose to do this:
;   
;   - The importance of backwards compatibility makes it unfeasible for us to
;   enforce real opaque references in the implementation anytime in the
;   foreseeable future.  Therefore, any opaque data types (e.g. WindowRef,
;   ControlRef, etc.) in the documentation and header files would always be a
;   fake veneer of opacity.
;   
;   - There exists a significant base of books and sample code that neophyte
;   Macintosh developers use to learn how to program the Macintosh.  These
;   books and sample code all use direct data access.  Introducing opaque data
;   types at this point would confuse neophyte programmers more than it would
;   help them.
;   
;   - Direct data structure access is used by nearly all Macintosh developers. 
;   Changing the interfaces to reflect a false opacity would not provide any
;   benefit to these developers.
;   
;   - Accessor functions are useful in and of themselves as convenience
;   functions, without being tied to opaque data types.  We will complete and
;   document the Windows and Dialogs accessor functions in an upcoming release
;   of the interfaces.

kWindowDefProcType				EQU		'WDEF'

;####################################################################################
;
;	Window Definition ID's
;
;####################################################################################
kStandardWindowDefinition		EQU		0					; for document windows and dialogs
kRoundWindowDefinition			EQU		1					; old da-style window
kFloatingWindowDefinition		EQU		124					; for floating windows

;####################################################################################
;
; Window Variant Codes
;
;####################################################################################
; for use with kStandardWindowDefinition 
kModalDialogVariantCode			EQU		1
kMovableModalDialogVariantCode	EQU		5
; for use with kFloatingWindowDefinition 
kSideFloaterVariantCode			EQU		8

;####################################################################################
;
; Old-style procIDs.  For use only with New(C)Window
;
;####################################################################################
documentProc					EQU		0
dBoxProc						EQU		1
plainDBox						EQU		2
altDBoxProc						EQU		3
noGrowDocProc					EQU		4
movableDBoxProc					EQU		5
zoomDocProc						EQU		8
zoomNoGrow						EQU		12
rDocProc						EQU		16
; floating window defproc ids 
floatProc						EQU		1985
floatGrowProc					EQU		1987
floatZoomProc					EQU		1989
floatZoomGrowProc				EQU		1991
floatSideProc					EQU		1993
floatSideGrowProc				EQU		1995
floatSideZoomProc				EQU		1997
floatSideZoomGrowProc			EQU		1999

;####################################################################################
;
; Standard window kinds
;
;####################################################################################
dialogKind						EQU		2
userKind						EQU		8
kDialogWindowKind				EQU		2
kApplicationWindowKind			EQU		8

;####################################################################################
;
; FindWindow result codes
;
;####################################################################################
inDesk							EQU		0
inMenuBar						EQU		1
inSysWindow						EQU		2
inContent						EQU		3
inDrag							EQU		4
inGrow							EQU		5
inGoAway						EQU		6
inZoomIn						EQU		7
inZoomOut						EQU		8

wDraw							EQU		0
wHit							EQU		1
wCalcRgns						EQU		2
wNew							EQU		3
wDispose						EQU		4
wGrow							EQU		5
wDrawGIcon						EQU		6

deskPatID						EQU		16

;####################################################################################
;
; Window Definition hit test result codes ("WindowPart")
;
;####################################################################################
wNoHit							EQU		0
wInContent						EQU		1
wInDrag							EQU		2
wInGrow							EQU		3
wInGoAway						EQU		4
wInZoomIn						EQU		5
wInZoomOut						EQU		6

;
; pascal RgnHandle GetGrayRgn(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GetGrayRgn		 &dest=(sp)
		move.l               $09EE,&dest
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GetGrayRgn
	ENDIF

;####################################################################################
;
;	Color table defined for compatibility only.  Will move to some ifdef'd wasteland.
;
;####################################################################################
WinCTab 				RECORD	0
wCSeed					 ds.l   1		; offset: $0 (0)		; reserved 
wCReserved				 ds.w   1		; offset: $4 (4)		; reserved 
ctSize					 ds.w   1		; offset: $6 (6)		; usually 4 for windows 
ctTable					 ds.b   5 * ColorSpec.sizeof ; offset: $8 (8)
sizeof					 EQU *			; size:   $30 (48)
						ENDR

; typedef struct WinCTab 	WinCTab
; typedef WinCTab 			*WCTabPtr, **WCTabHandle
;
; pascal void InitWindows(void)
;
	IF ¬ GENERATINGCFM THEN
		_InitWindows:	OPWORD	$A912
	ELSE
		IMPORT_CFM_FUNCTION	InitWindows
	ENDIF

;
; pascal void GetWMgrPort(GrafPtr *wPort)
;
	IF ¬ GENERATINGCFM THEN
		_GetWMgrPort:	OPWORD	$A910
	ELSE
		IMPORT_CFM_FUNCTION	GetWMgrPort
	ENDIF

;
; pascal WindowPtr NewWindow(void *wStorage, const Rect *boundsRect, ConstStr255Param title, Boolean visible, short theProc, WindowPtr behind, Boolean goAwayFlag, long refCon)
;
	IF ¬ GENERATINGCFM THEN
		_NewWindow:	OPWORD	$A913
	ELSE
		IMPORT_CFM_FUNCTION	NewWindow
	ENDIF

;
; pascal WindowPtr GetNewWindow(short windowID, void *wStorage, WindowPtr behind)
;
	IF ¬ GENERATINGCFM THEN
		_GetNewWindow:	OPWORD	$A9BD
	ELSE
		IMPORT_CFM_FUNCTION	GetNewWindow
	ENDIF

;
; pascal void CloseWindow(WindowPtr theWindow)
;
	IF ¬ GENERATINGCFM THEN
		_CloseWindow:	OPWORD	$A92D
	ELSE
		IMPORT_CFM_FUNCTION	CloseWindow
	ENDIF

;
; pascal void DisposeWindow(WindowPtr theWindow)
;
	IF ¬ GENERATINGCFM THEN
		_DisposeWindow:	OPWORD	$A914
	ELSE
		IMPORT_CFM_FUNCTION	DisposeWindow
	ENDIF

;
; pascal void GetWTitle(WindowPtr theWindow, Str255 title)
;
	IF ¬ GENERATINGCFM THEN
		_GetWTitle:	OPWORD	$A919
	ELSE
		IMPORT_CFM_FUNCTION	GetWTitle
	ENDIF

;
; pascal void SelectWindow(WindowPtr theWindow)
;
	IF ¬ GENERATINGCFM THEN
		_SelectWindow:	OPWORD	$A91F
	ELSE
		IMPORT_CFM_FUNCTION	SelectWindow
	ENDIF

;
; pascal void HideWindow(WindowPtr theWindow)
;
	IF ¬ GENERATINGCFM THEN
		_HideWindow:	OPWORD	$A916
	ELSE
		IMPORT_CFM_FUNCTION	HideWindow
	ENDIF

;
; pascal void ShowWindow(WindowPtr theWindow)
;
	IF ¬ GENERATINGCFM THEN
		_ShowWindow:	OPWORD	$A915
	ELSE
		IMPORT_CFM_FUNCTION	ShowWindow
	ENDIF

;
; pascal void ShowHide(WindowPtr theWindow, Boolean showFlag)
;
	IF ¬ GENERATINGCFM THEN
		_ShowHide:	OPWORD	$A908
	ELSE
		IMPORT_CFM_FUNCTION	ShowHide
	ENDIF

;
; pascal void HiliteWindow(WindowPtr theWindow, Boolean fHilite)
;
	IF ¬ GENERATINGCFM THEN
		_HiliteWindow:	OPWORD	$A91C
	ELSE
		IMPORT_CFM_FUNCTION	HiliteWindow
	ENDIF

;
; pascal void BringToFront(WindowPtr theWindow)
;
	IF ¬ GENERATINGCFM THEN
		_BringToFront:	OPWORD	$A920
	ELSE
		IMPORT_CFM_FUNCTION	BringToFront
	ENDIF

;
; pascal void SendBehind(WindowPtr theWindow, WindowPtr behindWindow)
;
	IF ¬ GENERATINGCFM THEN
		_SendBehind:	OPWORD	$A921
	ELSE
		IMPORT_CFM_FUNCTION	SendBehind
	ENDIF

;
; pascal WindowPtr FrontWindow(void)
;
	IF ¬ GENERATINGCFM THEN
		_FrontWindow:	OPWORD	$A924
	ELSE
		IMPORT_CFM_FUNCTION	FrontWindow
	ENDIF

;
; pascal void DrawGrowIcon(WindowPtr theWindow)
;
	IF ¬ GENERATINGCFM THEN
		_DrawGrowIcon:	OPWORD	$A904
	ELSE
		IMPORT_CFM_FUNCTION	DrawGrowIcon
	ENDIF

;
; pascal void MoveWindow(WindowPtr theWindow, short hGlobal, short vGlobal, Boolean front)
;
	IF ¬ GENERATINGCFM THEN
		_MoveWindow:	OPWORD	$A91B
	ELSE
		IMPORT_CFM_FUNCTION	MoveWindow
	ENDIF

;
; pascal void SizeWindow(WindowPtr theWindow, short w, short h, Boolean fUpdate)
;
	IF ¬ GENERATINGCFM THEN
		_SizeWindow:	OPWORD	$A91D
	ELSE
		IMPORT_CFM_FUNCTION	SizeWindow
	ENDIF

;
; pascal void ZoomWindow(WindowPtr theWindow, short partCode, Boolean front)
;
	IF ¬ GENERATINGCFM THEN
		_ZoomWindow:	OPWORD	$A83A
	ELSE
		IMPORT_CFM_FUNCTION	ZoomWindow
	ENDIF

;
; pascal void InvalRect(const Rect *badRect)
;
	IF ¬ GENERATINGCFM THEN
		_InvalRect:	OPWORD	$A928
	ELSE
		IMPORT_CFM_FUNCTION	InvalRect
	ENDIF

;
; pascal void InvalRgn(RgnHandle badRgn)
;
	IF ¬ GENERATINGCFM THEN
		_InvalRgn:	OPWORD	$A927
	ELSE
		IMPORT_CFM_FUNCTION	InvalRgn
	ENDIF

;
; pascal void ValidRect(const Rect *goodRect)
;
	IF ¬ GENERATINGCFM THEN
		_ValidRect:	OPWORD	$A92A
	ELSE
		IMPORT_CFM_FUNCTION	ValidRect
	ENDIF

;
; pascal void ValidRgn(RgnHandle goodRgn)
;
	IF ¬ GENERATINGCFM THEN
		_ValidRgn:	OPWORD	$A929
	ELSE
		IMPORT_CFM_FUNCTION	ValidRgn
	ENDIF

;
; pascal void BeginUpdate(WindowPtr theWindow)
;
	IF ¬ GENERATINGCFM THEN
		_BeginUpdate:	OPWORD	$A922
	ELSE
		IMPORT_CFM_FUNCTION	BeginUpdate
	ENDIF

;
; pascal void EndUpdate(WindowPtr theWindow)
;
	IF ¬ GENERATINGCFM THEN
		_EndUpdate:	OPWORD	$A923
	ELSE
		IMPORT_CFM_FUNCTION	EndUpdate
	ENDIF

;
; pascal void SetWRefCon(WindowPtr theWindow, long data)
;
	IF ¬ GENERATINGCFM THEN
		_SetWRefCon:	OPWORD	$A918
	ELSE
		IMPORT_CFM_FUNCTION	SetWRefCon
	ENDIF

;
; pascal long GetWRefCon(WindowPtr theWindow)
;
	IF ¬ GENERATINGCFM THEN
		_GetWRefCon:	OPWORD	$A917
	ELSE
		IMPORT_CFM_FUNCTION	GetWRefCon
	ENDIF

;
; pascal void SetWindowPic(WindowPtr theWindow, PicHandle pic)
;
	IF ¬ GENERATINGCFM THEN
		_SetWindowPic:	OPWORD	$A92E
	ELSE
		IMPORT_CFM_FUNCTION	SetWindowPic
	ENDIF

;
; pascal PicHandle GetWindowPic(WindowPtr theWindow)
;
	IF ¬ GENERATINGCFM THEN
		_GetWindowPic:	OPWORD	$A92F
	ELSE
		IMPORT_CFM_FUNCTION	GetWindowPic
	ENDIF

;
; pascal Boolean CheckUpdate(EventRecord *theEvent)
;
	IF ¬ GENERATINGCFM THEN
		_CheckUpdate:	OPWORD	$A911
	ELSE
		IMPORT_CFM_FUNCTION	CheckUpdate
	ENDIF

;
; pascal void ClipAbove(WindowPtr window)
;
	IF ¬ GENERATINGCFM THEN
		_ClipAbove:	OPWORD	$A90B
	ELSE
		IMPORT_CFM_FUNCTION	ClipAbove
	ENDIF

;
; pascal void SaveOld(WindowPtr window)
;
	IF ¬ GENERATINGCFM THEN
		_SaveOld:	OPWORD	$A90E
	ELSE
		IMPORT_CFM_FUNCTION	SaveOld
	ENDIF

;
; pascal void DrawNew(WindowPtr window, Boolean update)
;
	IF ¬ GENERATINGCFM THEN
		_DrawNew:	OPWORD	$A90F
	ELSE
		IMPORT_CFM_FUNCTION	DrawNew
	ENDIF

;
; pascal void PaintOne(WindowPtr window, RgnHandle clobberedRgn)
;
	IF ¬ GENERATINGCFM THEN
		_PaintOne:	OPWORD	$A90C
	ELSE
		IMPORT_CFM_FUNCTION	PaintOne
	ENDIF

;
; pascal void PaintBehind(WindowPtr startWindow, RgnHandle clobberedRgn)
;
	IF ¬ GENERATINGCFM THEN
		_PaintBehind:	OPWORD	$A90D
	ELSE
		IMPORT_CFM_FUNCTION	PaintBehind
	ENDIF

;
; pascal void CalcVis(WindowPtr window)
;
	IF ¬ GENERATINGCFM THEN
		_CalcVis:	OPWORD	$A909
	ELSE
		IMPORT_CFM_FUNCTION	CalcVis
	ENDIF

;
; pascal void CalcVisBehind(WindowPtr startWindow, RgnHandle clobberedRgn)
;
	IF ¬ GENERATINGCFM THEN
		_CalcVisBehind:	OPWORD	$A90A
	ELSE
		IMPORT_CFM_FUNCTION	CalcVisBehind
	ENDIF

;
; pascal long GrowWindow(WindowPtr theWindow, Point startPt, const Rect *bBox)
;
	IF ¬ GENERATINGCFM THEN
		_GrowWindow:	OPWORD	$A92B
	ELSE
		IMPORT_CFM_FUNCTION	GrowWindow
	ENDIF

;
; pascal short FindWindow(Point thePoint, WindowPtr *theWindow)
;
	IF ¬ GENERATINGCFM THEN
		_FindWindow:	OPWORD	$A92C
	ELSE
		IMPORT_CFM_FUNCTION	FindWindow
	ENDIF

;
; pascal long PinRect(const Rect *theRect, Point thePt)
;
	IF ¬ GENERATINGCFM THEN
		_PinRect:	OPWORD	$A94E
	ELSE
		IMPORT_CFM_FUNCTION	PinRect
	ENDIF

;
; pascal long DragGrayRgn(RgnHandle theRgn, Point startPt, const Rect *limitRect, const Rect *slopRect, short axis, DragGrayRgnUPP actionProc)
;
	IF ¬ GENERATINGCFM THEN
		_DragGrayRgn:	OPWORD	$A905
	ELSE
		IMPORT_CFM_FUNCTION	DragGrayRgn
	ENDIF

;
; pascal long DragTheRgn(RgnHandle theRgn, Point startPt, const Rect *limitRect, const Rect *slopRect, short axis, DragGrayRgnUPP actionProc)
;
	IF ¬ GENERATINGCFM THEN
		_DragTheRgn:	OPWORD	$A926
	ELSE
		IMPORT_CFM_FUNCTION	DragTheRgn
	ENDIF

;
; pascal Boolean TrackBox(WindowPtr theWindow, Point thePt, short partCode)
;
	IF ¬ GENERATINGCFM THEN
		_TrackBox:	OPWORD	$A83B
	ELSE
		IMPORT_CFM_FUNCTION	TrackBox
	ENDIF

;
; pascal void GetCWMgrPort(CGrafPtr *wMgrCPort)
;
	IF ¬ GENERATINGCFM THEN
		_GetCWMgrPort:	OPWORD	$AA48
	ELSE
		IMPORT_CFM_FUNCTION	GetCWMgrPort
	ENDIF

;
; pascal void SetWinColor(WindowPtr theWindow, WCTabHandle newColorTable)
;
	IF ¬ GENERATINGCFM THEN
		_SetWinColor:	OPWORD	$AA41
	ELSE
		IMPORT_CFM_FUNCTION	SetWinColor
	ENDIF

;
; pascal void SetDeskCPat(PixPatHandle deskPixPat)
;
	IF ¬ GENERATINGCFM THEN
		_SetDeskCPat:	OPWORD	$AA47
	ELSE
		IMPORT_CFM_FUNCTION	SetDeskCPat
	ENDIF

;
; pascal WindowPtr NewCWindow(void *wStorage, const Rect *boundsRect, ConstStr255Param title, Boolean visible, short procID, WindowPtr behind, Boolean goAwayFlag, long refCon)
;
	IF ¬ GENERATINGCFM THEN
		_NewCWindow:	OPWORD	$AA45
	ELSE
		IMPORT_CFM_FUNCTION	NewCWindow
	ENDIF

;
; pascal WindowPtr GetNewCWindow(short windowID, void *wStorage, WindowPtr behind)
;
	IF ¬ GENERATINGCFM THEN
		_GetNewCWindow:	OPWORD	$AA46
	ELSE
		IMPORT_CFM_FUNCTION	GetNewCWindow
	ENDIF

;
; pascal short GetWVariant(WindowPtr theWindow)
;
	IF ¬ GENERATINGCFM THEN
		_GetWVariant:	OPWORD	$A80A
	ELSE
		IMPORT_CFM_FUNCTION	GetWVariant
	ENDIF

;
; pascal void SetWTitle(WindowPtr theWindow, ConstStr255Param title)
;
	IF ¬ GENERATINGCFM THEN
		_SetWTitle:	OPWORD	$A91A
	ELSE
		IMPORT_CFM_FUNCTION	SetWTitle
	ENDIF

;
; pascal Boolean TrackGoAway(WindowPtr theWindow, Point thePt)
;
	IF ¬ GENERATINGCFM THEN
		_TrackGoAway:	OPWORD	$A91E
	ELSE
		IMPORT_CFM_FUNCTION	TrackGoAway
	ENDIF

;
; pascal void DragWindow(WindowPtr theWindow, Point startPt, const Rect *boundsRect)
;
	IF ¬ GENERATINGCFM THEN
		_DragWindow:	OPWORD	$A925
	ELSE
		IMPORT_CFM_FUNCTION	DragWindow
	ENDIF

; typedef struct WindowRecord  WindowRecord
; typedef WindowRecord 		*WindowPeek
WindowRecord 			RECORD	0
port					 ds     GrafPort ; offset: $0 (0)
windowKind				 ds.w   1		; offset: $6C (108)
visible					 ds.b   1		; offset: $6E (110)
hilited					 ds.b   1		; offset: $6F (111)
goAwayFlag				 ds.b   1		; offset: $70 (112)
spareFlag				 ds.b   1		; offset: $71 (113)
strucRgn				 ds.l   1		; offset: $72 (114)
contRgn					 ds.l   1		; offset: $76 (118)
updateRgn				 ds.l   1		; offset: $7A (122)
windowDefProc			 ds.l   1		; offset: $7E (126)
dataHandle				 ds.l   1		; offset: $82 (130)
titleHandle				 ds.l   1		; offset: $86 (134)
titleWidth				 ds.w   1		; offset: $8A (138)
controlList				 ds.l   1		; offset: $8C (140)
nextWindow				 ds.l   1		; offset: $90 (144)
windowPic				 ds.l   1		; offset: $94 (148)
refCon					 ds.l   1		; offset: $98 (152)
sizeof					 EQU *			; size:   $9C (156)
						ENDR

; typedef struct CWindowRecord  CWindowRecord
; typedef CWindowRecord 	*CWindowPeek
CWindowRecord 			RECORD	0
port					 ds     CGrafPort ; offset: $0 (0)
windowKind				 ds.w   1		; offset: $6C (108)
visible					 ds.b   1		; offset: $6E (110)
hilited					 ds.b   1		; offset: $6F (111)
goAwayFlag				 ds.b   1		; offset: $70 (112)
spareFlag				 ds.b   1		; offset: $71 (113)
strucRgn				 ds.l   1		; offset: $72 (114)
contRgn					 ds.l   1		; offset: $76 (118)
updateRgn				 ds.l   1		; offset: $7A (122)
windowDefProc			 ds.l   1		; offset: $7E (126)
dataHandle				 ds.l   1		; offset: $82 (130)
titleHandle				 ds.l   1		; offset: $86 (134)
titleWidth				 ds.w   1		; offset: $8A (138)
controlList				 ds.l   1		; offset: $8C (140)
nextWindow				 ds.l   1		; offset: $90 (144)
windowPic				 ds.l   1		; offset: $94 (148)
refCon					 ds.l   1		; offset: $98 (152)
sizeof					 EQU *			; size:   $9C (156)
						ENDR

WStateData 				RECORD	0
userState				 ds     Rect	; offset: $0 (0)		;user state
stdState				 ds     Rect	; offset: $8 (8)		;standard state
sizeof					 EQU *			; size:   $10 (16)
						ENDR

; typedef struct WStateData  WStateData
; typedef WStateData 		*WStateDataPtr, **WStateDataHandle
; typedef struct AuxWinRec 	AuxWinRec
; typedef AuxWinRec 		*AuxWinPtr, **AuxWinHandle
AuxWinRec 				RECORD	0
awNext					 ds.l   1		; offset: $0 (0)		;handle to next AuxWinRec
awOwner					 ds.l   1		; offset: $4 (4)		;ptr to window 
awCTable				 ds.l   1		; offset: $8 (8)		;color table for this window
reserved				 ds.l   1		; offset: $C (12)		;  
awFlags					 ds.l   1		; offset: $10 (16)		;reserved for expansion
awReserved				 ds.l   1		; offset: $14 (20)		;reserved for expansion
awRefCon				 ds.l   1		; offset: $18 (24)		;user Constant
sizeof					 EQU *			; size:   $1C (28)
						ENDR

;
; pascal Boolean GetAuxWin(WindowPtr theWindow, AuxWinHandle *awHndl)
;
	IF ¬ GENERATINGCFM THEN
		_GetAuxWin:	OPWORD	$AA42
	ELSE
		IMPORT_CFM_FUNCTION	GetAuxWin
	ENDIF


wContentColor					EQU		0
wFrameColor						EQU		1
wTextColor						EQU		2
wHiliteColor					EQU		3
wTitleBarColor					EQU		4



	ENDIF ; __WINDOWS__

