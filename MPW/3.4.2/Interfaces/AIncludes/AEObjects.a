;
;	File:		AEObjects.a
;
;	Contains:	AppleEvents Interfaces.
;
;	Version:	Technology:	System 7.5
;				Package:	Universal Interfaces 2.2 in “MPW” on ETO #20
;
;	Copyright:	© 1984-1995 by Apple Computer, Inc.
;				All rights reserved.
;
;	Bugs?:		If you find a problem with this file, use the Apple Bug Reporter
;				stack.  Include the file and version information (from above)
;				in the problem description and send to:
;					Internet:	apple.bugs@applelink.apple.com
;					AppleLink:	APPLE.BUGS
;
;

	IF &TYPE('__AEOBJECTS__') = 'UNDEFINED' THEN
__AEOBJECTS__ SET 1


	IF &TYPE('__MEMORY__') = 'UNDEFINED' THEN
	include 'Memory.a'
	ENDIF
;		include 'Types.a'											;
;			include 'ConditionalMacros.a'							;
;		include 'MixedMode.a'										;

	IF &TYPE('__OSUTILS__') = 'UNDEFINED' THEN
	include 'OSUtils.a'
	ENDIF

	IF &TYPE('__QUICKDRAW__') = 'UNDEFINED' THEN
	include 'Quickdraw.a'
	ENDIF
;		include 'QuickdrawText.a'									;

	IF &TYPE('__EVENTS__') = 'UNDEFINED' THEN
	include 'Events.a'
	ENDIF

	IF &TYPE('__EPPC__') = 'UNDEFINED' THEN
	include 'EPPC.a'
	ENDIF
;		include 'Errors.a'											;
;		include 'AppleTalk.a'										;
;		include 'Files.a'											;
;			include 'Finder.a'										;
;		include 'PPCToolbox.a'										;
;		include 'Processes.a'										;

	IF &TYPE('__APPLEEVENTS__') = 'UNDEFINED' THEN
	include 'AppleEvents.a'
	ENDIF
;		include 'Notification.a'									;

	IF &TYPE('__ERRORS__') = 'UNDEFINED' THEN
	include 'Errors.a'
	ENDIF

kAEAND							EQU		'AND '				;  0x414e4420  
kAEOR							EQU		'OR  '				;  0x4f522020  
kAENOT							EQU		'NOT '				;  0x4e4f5420  
;***	ABSOLUTE ORDINAL CONSTANTS	***
kAEFirst						EQU		'firs'				;  0x66697273  
kAELast							EQU		'last'				;  0x6c617374  
kAEMiddle						EQU		'midd'				;  0x6d696464  
kAEAny							EQU		'any '				;  0x616e7920  
kAEAll							EQU		'all '				;  0x616c6c20  
;***	RELATIVE ORDINAL CONSTANTS	***
kAENext							EQU		'next'				;  0x6e657874  
kAEPrevious						EQU		'prev'				;  0x70726576  
;***	KEYWORD CONSTANT 	***
keyAECompOperator				EQU		'relo'				;  0x72656c6f  
keyAELogicalTerms				EQU		'term'				;  0x7465726d  
keyAELogicalOperator			EQU		'logc'				;  0x6c6f6763  
keyAEObject1					EQU		'obj1'				;  0x6f626a31  
keyAEObject2					EQU		'obj2'				;  0x6f626a32  
;	... for Keywords for getting fields out of object specifier records. 
keyAEDesiredClass				EQU		'want'				;  0x77616e74  
keyAEContainer					EQU		'from'				;  0x66726f6d  
keyAEKeyForm					EQU		'form'				;  0x666f726d  
keyAEKeyData					EQU		'seld'

;	... for Keywords for getting fields out of Range specifier records. 
keyAERangeStart					EQU		'star'				;  0x73746172  
keyAERangeStop					EQU		'stop'				;  0x73746f70  
;	... special handler selectors for OSL Callbacks. 
keyDisposeTokenProc				EQU		'xtok'				;  0x78746f6b  
keyAECompareProc				EQU		'cmpr'				;  0x636d7072  
keyAECountProc					EQU		'cont'				;  0x636f6e74  
keyAEMarkTokenProc				EQU		'mkid'				;  0x6d6b6964  
keyAEMarkProc					EQU		'mark'				;  0x6d61726b  
keyAEAdjustMarksProc			EQU		'adjm'				;  0x61646a6d  
keyAEGetErrDescProc				EQU		'indc'

;***	VALUE and TYPE CONSTANTS	***
;	... possible values for the keyAEKeyForm field of an object specifier. 
formAbsolutePosition			EQU		'indx'				;  0x696e6478  
formRelativePosition			EQU		'rele'				;  0x72656c65  
formTest						EQU		'test'				;  0x74657374  
formRange						EQU		'rang'				;  0x72616e67  
formPropertyID					EQU		'prop'				;  0x70726f70  
formName						EQU		'name'				;  0x6e616d65  
;	... relevant types (some of these are often pared with forms above). 
typeObjectSpecifier				EQU		'obj '				;  0x6f626a20  
typeObjectBeingExamined			EQU		'exmn'				;  0x65786d6e  
typeCurrentContainer			EQU		'ccnt'				;  0x63636e74  
typeToken						EQU		'toke'				;  0x746f6b65  
typeRelativeDescriptor			EQU		'rel '				;  0x72656c20  
typeAbsoluteOrdinal				EQU		'abso'				;  0x6162736f  
typeIndexDescriptor				EQU		'inde'				;  0x696e6465  
typeRangeDescriptor				EQU		'rang'				;  0x72616e67  
typeLogicalDescriptor			EQU		'logi'				;  0x6c6f6769  
typeCompDescriptor				EQU		'cmpd'				;  0x636d7064  
typeOSLTokenList				EQU		'ostl'

; Possible values for flags parameter to AEResolve.  They're additive 
kAEIDoMinimum					EQU		$0000
kAEIDoWhose						EQU		$0001
kAEIDoMarking					EQU		$0004
kAEPassSubDescs					EQU		$0008
kAEResolveNestedLists			EQU		$0010
kAEHandleSimpleRanges			EQU		$0020
kAEUseRelativeIterators			EQU		$0040

;*** SPECIAL CONSTANTS FOR CUSTOM WHOSE-CLAUSE RESOLUTION 
typeWhoseDescriptor				EQU		'whos'				;  0x77686f73  
formWhose						EQU		'whos'				;  0x77686f73  
typeWhoseRange					EQU		'wrng'				;  0x77726e67  
keyAEWhoseRangeStart			EQU		'wstr'				;  0x77737472  
keyAEWhoseRangeStop				EQU		'wstp'				;  0x77737470  
keyAEIndex						EQU		'kidx'				;  0x6b696478  
keyAETest						EQU		'ktst'

;*
;	used for rewriting tokens in place of 'ccnt' descriptors
;	This record is only of interest to those who, when they...
;	...get ranges as key data in their accessor procs, choose
;	...to resolve them manually rather than call AEResolve again.
;*
ccntTokenRecord 		RECORD	0
tokenClass				 ds.l   1		; offset: $0 (0)
token					 ds     AEDesc	; offset: $4 (4)
sizeof					 EQU *			; size:   $C (12)
						ENDR

; typedef struct ccntTokenRecord  ccntTokenRecord, *ccntTokenRecPtr, **ccntTokenRecHandle
	IF OLDROUTINENAMES  THEN
; typedef AEDesc 			*DescPtr, **DescHandle
	ENDIF
;
; pascal OSErr AEObjectInit(void)
;
	IF GENERATINGCFM THEN
		IMPORT_CFM_FUNCTION	AEObjectInit
	ENDIF

; Not done by inline, but by direct linking into code.  It sets up the pack
;  such that further calls can be via inline 
;
; pascal OSErr AESetObjectCallbacks(OSLCompareUPP myCompareProc, OSLCountUPP myCountProc, OSLDisposeTokenUPP myDisposeTokenProc, OSLGetMarkTokenUPP myGetMarkTokenProc, OSLMarkUPP myMarkProc, OSLAdjustMarksUPP myAdjustMarksProc, OSLGetErrDescUPP myGetErrDescProcPtr)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AESetObjectCallbacks
			move.w	#$0E35,d0
			dc.w 	$A816
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AESetObjectCallbacks
	ENDIF

;
; pascal OSErr AEResolve(const AEDesc *objectSpecifier, short callbackFlags, AEDesc *theToken)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AEResolve
			move.w	#$0536,d0
			dc.w 	$A816
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AEResolve
	ENDIF

;
; pascal OSErr AEInstallObjectAccessor(DescType desiredClass, DescType containerType, OSLAccessorUPP theAccessor, long accessorRefcon, Boolean isSysHandler)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AEInstallObjectAccessor
			move.w	#$0937,d0
			dc.w 	$A816
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AEInstallObjectAccessor
	ENDIF

;
; pascal OSErr AERemoveObjectAccessor(DescType desiredClass, DescType containerType, OSLAccessorUPP theAccessor, Boolean isSysHandler)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AERemoveObjectAccessor
			move.w	#$0738,d0
			dc.w 	$A816
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AERemoveObjectAccessor
	ENDIF

;
; pascal OSErr AEGetObjectAccessor(DescType desiredClass, DescType containerType, OSLAccessorUPP *accessor, long *accessorRefcon, Boolean isSysHandler)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AEGetObjectAccessor
			move.w	#$0939,d0
			dc.w 	$A816
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AEGetObjectAccessor
	ENDIF

;
; pascal OSErr AEDisposeToken(AEDesc *theToken)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AEDisposeToken
			move.w	#$023A,d0
			dc.w 	$A816
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AEDisposeToken
	ENDIF

;
; pascal OSErr AECallObjectAccessor(DescType desiredClass, const AEDesc *containerToken, DescType containerClass, DescType keyForm, const AEDesc *keyData, AEDesc *token)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_AECallObjectAccessor
			move.w	#$0C3B,d0
			dc.w 	$A816
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	AECallObjectAccessor
	ENDIF

	ENDIF ; __AEOBJECTS__
