;
;	File:		Dialogs.a
;
;	Contains:	Dialog Manager interfaces.
;
;	Version:	Technology:	System 7.5
;				Package:	Universal Interfaces 2.2.5
;
;	Copyright:	© 1984-1997 by Apple Computer, Inc.
;				All rights reserved.
;
;	Bugs?:		If you find a problem with this file, use the Apple Bug Reporter
;				stack.  Include the file and version information (from above)
;				in the problem description and send to:
;					Internet:	apple.bugs@applelink.apple.com
;					AppleLink:	APPLE.BUGS
;
;

	IF &TYPE('__DIALOGS__') = 'UNDEFINED' THEN
__DIALOGS__ SET 1


	IF &TYPE('__ERRORS__') = 'UNDEFINED' THEN
	include 'Errors.a'
	ENDIF
;		include 'ConditionalMacros.a'								;

	IF &TYPE('__MEMORY__') = 'UNDEFINED' THEN
	include 'Memory.a'
	ENDIF
;		include 'Types.a'											;
;		include 'MixedMode.a'										;

	IF &TYPE('__MENUS__') = 'UNDEFINED' THEN
	include 'Menus.a'
	ENDIF
;		include 'Quickdraw.a'										;
;			include 'QuickdrawText.a'								;

	IF &TYPE('__CONTROLS__') = 'UNDEFINED' THEN
	include 'Controls.a'
	ENDIF

	IF &TYPE('__WINDOWS__') = 'UNDEFINED' THEN
	include 'Windows.a'
	ENDIF
;		include 'Events.a'											;
;			include 'OSUtils.a'									;

	IF &TYPE('__TEXTEDIT__') = 'UNDEFINED' THEN
	include 'TextEdit.a'
	ENDIF

	IF &TYPE('__EVENTS__') = 'UNDEFINED' THEN
	include 'Events.a'
	ENDIF

;   *****************************************************************************
;   *                                                                           *
;   * The conditional STRICT_DIALOGS has been removed from this interface file. *
;   * The accessor macros to a DialogRecord are no longer necessary.            *
;   *                                                                           *
;   * All ≈Ref Types have reverted to their original Handle and Ptr Types.      *
;   *                                                                           *
;   *****************************************************************************
;   
;   Details:
;   The original purpose of the STRICT_ conditionals and accessor macros was to
;   help ease the transition to Copland.  Shared data structures are difficult
;   to coordinate in a preemptive multitasking OS.  By hiding the fields in a
;   WindowRecord and other data structures, we would begin the migration to the
;   discipline wherein system data structures are completely hidden from
;   applications.
;   
;   After many design reviews, we finally concluded that with this sort of
;   migration, the system could never tell when an application was no longer
;   peeking at a WindowRecord, and thus the data structure might never become
;   system owned.  Additionally, there were many other limitations in the
;   classic toolbox that were begging to be addressed.  The final decision was
;   to leave the traditional toolbox as a compatibility mode.
;   
;   We also decided to use the Handle and Ptr based types in the function
;   declarations.  For example, NewWindow now returns a WindowPtr rather than a
;   WindowRef.  The Ref types are still defined in the header files, so all
;   existing code will still compile exactly as it did before.  There are
;   several reasons why we chose to do this:
;   
;   - The importance of backwards compatibility makes it unfeasible for us to
;   enforce real opaque references in the implementation anytime in the
;   foreseeable future.  Therefore, any opaque data types (e.g. WindowRef,
;   ControlRef, etc.) in the documentation and header files would always be a
;   fake veneer of opacity.
;   
;   - There exists a significant base of books and sample code that neophyte
;   Macintosh developers use to learn how to program the Macintosh.  These
;   books and sample code all use direct data access.  Introducing opaque data
;   types at this point would confuse neophyte programmers more than it would
;   help them.
;   
;   - Direct data structure access is used by nearly all Macintosh developers. 
;   Changing the interfaces to reflect a false opacity would not provide any
;   benefit to these developers.
;   
;   - Accessor functions are useful in and of themselves as convenience
;   functions, without being tied to opaque data types.  We will complete and
;   document the Windows and Dialogs accessor functions in an upcoming release
;   of the interfaces.

ctrlItem						EQU		4
btnCtrl							EQU		0
chkCtrl							EQU		1
radCtrl							EQU		2
resCtrl							EQU		3
statText						EQU		8
editText						EQU		16
iconItem						EQU		32
picItem							EQU		64
userItem						EQU		0
itemDisable						EQU		128
ok								EQU		1
cancel							EQU		2
stopIcon						EQU		0
noteIcon						EQU		1
cautionIcon						EQU		2

; new, more standard names for dialog item constants 
kControlDialogItem				EQU		ctrlItem
kButtonDialogItem				EQU		ctrlItem + btnCtrl
kCheckBoxDialogItem				EQU		ctrlItem + chkCtrl
kRadioButtonDialogItem			EQU		ctrlItem + radCtrl
kResourceControlDialogItem		EQU		ctrlItem + resCtrl
kStaticTextDialogItem			EQU		statText
kEditTextDialogItem				EQU		editText
kIconDialogItem					EQU		iconItem
kPictureDialogItem				EQU		picItem
kUserDialogItem					EQU		userItem
kItemDisableBit					EQU		itemDisable
kStdOkItemIndex					EQU		ok
kStdCancelItemIndex				EQU		cancel
kStopIcon						EQU		stopIcon
kNoteIcon						EQU		noteIcon
kCautionIcon					EQU		cautionIcon

	IF OLDROUTINENAMES  THEN
kOkItemIndex					EQU		kStdOkItemIndex
kCancelItemIndex				EQU		kStdCancelItemIndex

	ENDIF
; typedef SInt16 			DITLMethod

overlayDITL						EQU		0
appendDITLRight					EQU		1
appendDITLBottom				EQU		2

; typedef short 			StageList
; typedef OSType 			DialogPropertyTag
; typedef WindowPtr 		DialogPtr
; typedef DialogPtr 		DialogRef
DialogRecord 			RECORD	0
window					 ds     WindowRecord ; offset: $0 (0)
items					 ds.l   1		; offset: $9C (156)
textH					 ds.l   1		; offset: $A0 (160)
editField				 ds.w   1		; offset: $A4 (164)
editOpen				 ds.w   1		; offset: $A6 (166)
aDefItem				 ds.w   1		; offset: $A8 (168)
sizeof					 EQU *			; size:   $AA (170)
						ENDR

; typedef struct DialogRecord  DialogRecord
; typedef DialogRecord 		*DialogPeek
DialogTemplate 			RECORD	0
boundsRect				 ds     Rect	; offset: $0 (0)
procID					 ds.w   1		; offset: $8 (8)
visible					 ds.b   1		; offset: $A (10)
filler1					 ds.b   1		; offset: $B (11)
goAwayFlag				 ds.b   1		; offset: $C (12)
filler2					 ds.b   1		; offset: $D (13)
refCon					 ds.l   1		; offset: $E (14)
itemsID					 ds.w   1		; offset: $12 (18)
title					 ds.l   64		; offset: $14 (20)
sizeof					 EQU *			; size:   $114 (276)
						ENDR

; typedef struct DialogTemplate  DialogTemplate
; typedef DialogTemplate 	*DialogTPtr, **DialogTHndl
AlertTemplate 			RECORD	0
boundsRect				 ds     Rect	; offset: $0 (0)
itemsID					 ds.w   1		; offset: $8 (8)
stages					 ds.w   1		; offset: $A (10)
sizeof					 EQU *			; size:   $C (12)
						ENDR

; typedef struct AlertTemplate  AlertTemplate
; typedef AlertTemplate 	*AlertTPtr, **AlertTHndl
;
; pascal void InitDialogs(void *ignored)
;
	IF ¬ GENERATINGCFM THEN
		_InitDialogs:	OPWORD	$A97B
	ELSE
		IMPORT_CFM_FUNCTION	InitDialogs
	ENDIF

;
; pascal void ErrorSound(SoundUPP soundProc)
;
	IF ¬ GENERATINGCFM THEN
		_ErrorSound:	OPWORD	$A98C
	ELSE
		IMPORT_CFM_FUNCTION	ErrorSound
	ENDIF

;
; pascal DialogPtr NewDialog(void *wStorage, const Rect *boundsRect, ConstStr255Param title, Boolean visible, short procID, WindowPtr behind, Boolean goAwayFlag, long refCon, Handle itmLstHndl)
;
	IF ¬ GENERATINGCFM THEN
		_NewDialog:	OPWORD	$A97D
	ELSE
		IMPORT_CFM_FUNCTION	NewDialog
	ENDIF

;
; pascal DialogPtr GetNewDialog(short dialogID, void *dStorage, WindowPtr behind)
;
	IF ¬ GENERATINGCFM THEN
		_GetNewDialog:	OPWORD	$A97C
	ELSE
		IMPORT_CFM_FUNCTION	GetNewDialog
	ENDIF

;
; pascal void CloseDialog(DialogPtr theDialog)
;
	IF ¬ GENERATINGCFM THEN
		_CloseDialog:	OPWORD	$A982
	ELSE
		IMPORT_CFM_FUNCTION	CloseDialog
	ENDIF

;
; pascal void DisposeDialog(DialogPtr theDialog)
;
	IF ¬ GENERATINGCFM THEN
		_DisposeDialog:	OPWORD	$A983
	ELSE
		IMPORT_CFM_FUNCTION	DisposeDialog
	ENDIF

;
; pascal void ParamText(ConstStr255Param param0, ConstStr255Param param1, ConstStr255Param param2, ConstStr255Param param3)
;
	IF ¬ GENERATINGCFM THEN
		_ParamText:	OPWORD	$A98B
	ELSE
		IMPORT_CFM_FUNCTION	ParamText
	ENDIF

;
; pascal void ModalDialog(ModalFilterUPP modalFilter, short *itemHit)
;
	IF ¬ GENERATINGCFM THEN
		_ModalDialog:	OPWORD	$A991
	ELSE
		IMPORT_CFM_FUNCTION	ModalDialog
	ENDIF

;
; pascal Boolean IsDialogEvent(const EventRecord *theEvent)
;
	IF ¬ GENERATINGCFM THEN
		_IsDialogEvent:	OPWORD	$A97F
	ELSE
		IMPORT_CFM_FUNCTION	IsDialogEvent
	ENDIF

;
; pascal Boolean DialogSelect(const EventRecord *theEvent, DialogPtr *theDialog, short *itemHit)
;
	IF ¬ GENERATINGCFM THEN
		_DialogSelect:	OPWORD	$A980
	ELSE
		IMPORT_CFM_FUNCTION	DialogSelect
	ENDIF

;
; pascal void DrawDialog(DialogPtr theDialog)
;
	IF ¬ GENERATINGCFM THEN
		_DrawDialog:	OPWORD	$A981
	ELSE
		IMPORT_CFM_FUNCTION	DrawDialog
	ENDIF

;
; pascal void UpdateDialog(DialogPtr theDialog, RgnHandle updateRgn)
;
	IF ¬ GENERATINGCFM THEN
		_UpdateDialog:	OPWORD	$A978
	ELSE
		IMPORT_CFM_FUNCTION	UpdateDialog
	ENDIF

;
; pascal short Alert(short alertID, ModalFilterUPP modalFilter)
;
	IF ¬ GENERATINGCFM THEN
		_Alert:	OPWORD	$A985
	ELSE
		IMPORT_CFM_FUNCTION	Alert
	ENDIF

;
; pascal short StopAlert(short alertID, ModalFilterUPP modalFilter)
;
	IF ¬ GENERATINGCFM THEN
		_StopAlert:	OPWORD	$A986
	ELSE
		IMPORT_CFM_FUNCTION	StopAlert
	ENDIF

;
; pascal short NoteAlert(short alertID, ModalFilterUPP modalFilter)
;
	IF ¬ GENERATINGCFM THEN
		_NoteAlert:	OPWORD	$A987
	ELSE
		IMPORT_CFM_FUNCTION	NoteAlert
	ENDIF

;
; pascal short CautionAlert(short alertID, ModalFilterUPP modalFilter)
;
	IF ¬ GENERATINGCFM THEN
		_CautionAlert:	OPWORD	$A988
	ELSE
		IMPORT_CFM_FUNCTION	CautionAlert
	ENDIF

;
; pascal void GetDialogItem(DialogPtr theDialog, short itemNo, short *itemType, Handle *item, Rect *box)
;
	IF ¬ GENERATINGCFM THEN
		_GetDialogItem:	OPWORD	$A98D
	ELSE
		IMPORT_CFM_FUNCTION	GetDialogItem
	ENDIF

;
; pascal void SetDialogItem(DialogPtr theDialog, short itemNo, short itemType, Handle item, const Rect *box)
;
	IF ¬ GENERATINGCFM THEN
		_SetDialogItem:	OPWORD	$A98E
	ELSE
		IMPORT_CFM_FUNCTION	SetDialogItem
	ENDIF

;
; pascal void HideDialogItem(DialogPtr theDialog, short itemNo)
;
	IF ¬ GENERATINGCFM THEN
		_HideDialogItem:	OPWORD	$A827
	ELSE
		IMPORT_CFM_FUNCTION	HideDialogItem
	ENDIF

;
; pascal void ShowDialogItem(DialogPtr theDialog, short itemNo)
;
	IF ¬ GENERATINGCFM THEN
		_ShowDialogItem:	OPWORD	$A828
	ELSE
		IMPORT_CFM_FUNCTION	ShowDialogItem
	ENDIF

;
; pascal void SelectDialogItemText(DialogPtr theDialog, short itemNo, short strtSel, short endSel)
;
	IF ¬ GENERATINGCFM THEN
		_SelectDialogItemText:	OPWORD	$A97E
	ELSE
		IMPORT_CFM_FUNCTION	SelectDialogItemText
	ENDIF

;
; pascal void GetDialogItemText(Handle item, Str255 text)
;
	IF ¬ GENERATINGCFM THEN
		_GetDialogItemText:	OPWORD	$A990
	ELSE
		IMPORT_CFM_FUNCTION	GetDialogItemText
	ENDIF

;
; pascal void SetDialogItemText(Handle item, ConstStr255Param text)
;
	IF ¬ GENERATINGCFM THEN
		_SetDialogItemText:	OPWORD	$A98F
	ELSE
		IMPORT_CFM_FUNCTION	SetDialogItemText
	ENDIF

;
; pascal short FindDialogItem(DialogPtr theDialog, Point thePt)
;
	IF ¬ GENERATINGCFM THEN
		_FindDialogItem:	OPWORD	$A984
	ELSE
		IMPORT_CFM_FUNCTION	FindDialogItem
	ENDIF

;
; pascal DialogPtr NewColorDialog(void *dStorage, const Rect *boundsRect, ConstStr255Param title, Boolean visible, short procID, WindowPtr behind, Boolean goAwayFlag, long refCon, Handle items)
;
	IF ¬ GENERATINGCFM THEN
		_NewColorDialog:	OPWORD	$AA4B
	ELSE
		IMPORT_CFM_FUNCTION	NewColorDialog
	ENDIF

;
; pascal short GetAlertStage(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GetAlertStage		 &dest=(sp)
		move.w               $0A9A,&dest
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GetAlertStage
	ENDIF

;
; pascal void ResetAlertStage(void)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_ResetAlertStage
			dc.w 	$4278
			dc.w 	$0A9A
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	ResetAlertStage
	ENDIF

;
; pascal void SetDialogFont(short value)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SetDialogFont		 &src=(sp)+
		move.w               &src,$0AFA
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SetDialogFont
	ENDIF

;
; pascal void AppendDITL(DialogPtr theDialog, Handle theHandle, DITLMethod method)
;
	IF GENERATINGCFM THEN
		IMPORT_CFM_FUNCTION	AppendDITL
	ENDIF

;
; pascal short CountDITL(DialogPtr theDialog)
;
	IF GENERATINGCFM THEN
		IMPORT_CFM_FUNCTION	CountDITL
	ENDIF

;
; pascal void ShortenDITL(DialogPtr theDialog, short numberItems)
;
	IF GENERATINGCFM THEN
		IMPORT_CFM_FUNCTION	ShortenDITL
	ENDIF

;
; pascal OSErr GetStdFilterProc(ModalFilterUPP *theProc)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_GetStdFilterProc
			move.w	#$0203,d0
			dc.w 	$AA68
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	GetStdFilterProc
	ENDIF

;
; pascal OSErr SetDialogDefaultItem(DialogPtr theDialog, short newItem)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SetDialogDefaultItem
			move.w	#$0304,d0
			dc.w 	$AA68
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SetDialogDefaultItem
	ENDIF

;
; pascal OSErr SetDialogCancelItem(DialogPtr theDialog, short newItem)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SetDialogCancelItem
			move.w	#$0305,d0
			dc.w 	$AA68
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SetDialogCancelItem
	ENDIF

;
; pascal OSErr SetDialogTracksCursor(DialogPtr theDialog, Boolean tracks)
;
	IF ¬ GENERATINGCFM THEN
		Macro
		_SetDialogTracksCursor
			move.w	#$0306,d0
			dc.w 	$AA68
		EndM
	ELSE
		IMPORT_CFM_FUNCTION	SetDialogTracksCursor
	ENDIF

	IF OLDROUTINENAMES  THEN
	IF ¬ GENERATINGCFM  THEN
;
; pascal void CouldDialog(short dialogID)
;
	IF ¬ GENERATINGCFM THEN
		_CouldDialog:	OPWORD	$A979
	ELSE
		IMPORT_CFM_FUNCTION	CouldDialog
	ENDIF

;
; pascal void FreeDialog(short dialogID)
;
	IF ¬ GENERATINGCFM THEN
		_FreeDialog:	OPWORD	$A97A
	ELSE
		IMPORT_CFM_FUNCTION	FreeDialog
	ENDIF

;
; pascal void CouldAlert(short alertID)
;
	IF ¬ GENERATINGCFM THEN
		_CouldAlert:	OPWORD	$A989
	ELSE
		IMPORT_CFM_FUNCTION	CouldAlert
	ENDIF

;
; pascal void FreeAlert(short alertID)
;
	IF ¬ GENERATINGCFM THEN
		_FreeAlert:	OPWORD	$A98A
	ELSE
		IMPORT_CFM_FUNCTION	FreeAlert
	ENDIF

	ENDIF
	ELSE
	ENDIF
	ENDIF ; __DIALOGS__
