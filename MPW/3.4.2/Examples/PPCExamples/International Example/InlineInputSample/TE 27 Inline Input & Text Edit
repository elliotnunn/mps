TE 27 Ğ Inline Input for TextEdit with TSMTETextWritten by:	Yasuo Kida, Keisuke Hara, Nobuhiro Miyatake,	December 1993		Peter Sparks, Norbert LindenbergThis Technical Note describes TSMTE, an extension that simplifies implementation of inline input for TextEdit using the Text Services Manager in System 7.1 and later, and shows you how to make the best use of it. It also contains some advice for working with the Text Services Manager that applies to any application using TSM, not just those using TSMTE.Topics¥ What is TSMTE¥ Where and how is TSMTE delivered¥ How is TSMTE used in an application¥ Advice for working with the Text Services ManagerIntroductionSystem 7.1 introduced a new Toolbox manager, the Text Services Manager, that makes it easier for applications to provide inline input for 2-byte script systems (see Inside Macintosh: Text, pages 7-6 to 7-12, for an overview). To implement inline input using the Text Services Manager, an application has to do two things: make some calls to the Text Services Manager in the right places, and provide Apple event handlers that respond to events from input methods by updating text data structures, displaying text, and translating text offsets and screen coordinates. The first part is easy (maybe 50-100 lines of code), the second part can, depending on the complexity of the text engine that you use, require substantial work (several hundred to thousands of lines of code).TSMTE is an extension to the Text Services Manager that does the second part of the work for you if you use TextEdit. It provides Apple event handlers that handle all interactions between an input method and TextEdit. The handlers are kept in the system heap, so they are shared between all applications.TSMTE thus can reduce the effort needed to implement inline input to a day or two. If you use TextEdit in documents or modeless dialogs, you have to make a few calls to TSMTE in exchange for its help; if you use TextEdit only in modal dialogs, you only have to modify the DLOG resources that define them.If you use a text engine other than TextEdit for editing in your application, you can still use TSMTE to handle inline input wherever you use TextEdit, e.g., in dialogs.Note:	KanjiTalk 6.0.7 had an extension that provided fully automatic support for inline input with TextEdit without any kind of modification to applications. With TSMTE, inline input is not quite so automatic Ğ you have to make the necessary calls to TSMTE and the Text Services Manager to make it work.Note:	Inside Macintosh: Text, pages 2-107 to 2-109, discusses two feature bits, teFUseTextServices and teFInlineInput. TeFUseTextServices doesnÕt have any impact on the Text Services Manager or TSMTE, so you can safely ignore it. TeFInlineInput is handled by TSMTE, so there is no need for you to touch it.TSMTE OverviewAvailabilityCurrently, TSMTE is delivered as a system extension called ÒInline Tuika KinouÓ, which is shown here: Figure 1ĞInline Tuika Kinou extension fileIf you look for this file while running system software in some language using the Roman script system, the name of the extension file will be displayed as ÒƒCƒ“ƒ‰ƒCƒ“’Ç‰Á‹@”\Ó.The extension is part of the Japanese version of System 7.1, KanjiTalk 7. It is not part of the Japanese Language Kit or of any other version of System 7.1. This means that if you use TSMTE to implement inline input, it will currently only benefit users of Japanese system software. However, TSMTE may get rolled into a future version of the base system software, so that it would then be available for use with any 2-byte script system on any Macintosh worldwide. Your application should therefore use Gestalt to check for the presence of TSMTE and use it whenever it is available.For development purposes, if you donÕt feel comfortable using Japanese system software, you can install the Japanese Language Kit and the Inline Tuika Kinou extension into system software in any language that you like. Apple does not exactly guarantee that these configurations will work, but our experience so far has been good. Final testing should of course be done on a real Japanese system. In order to get your application to use a Japanese font in dialogs or in documents where you donÕt allow the user to select a font, you have to register your application as Japanese using the Language Register application that comes with the Japanese Language Kit.LimitationsYou may find that with some fonts TSMTE truncates the lower portion of characters drawn in the input area because it reserves a two-pixel high area for underlining. This problem will be fixed in a future release.PrerequisitesTo use the Text Services Manager and TSMTE, your application has to support Apple events. This means that it has to install Apple event handlers at least for the four required event types, and has to set the isHighLevelEventAware bit in the SIZE -1 resource.Note:	The SIZE resource also has a useTextEditServices bit. Contrary to the comments in Types.r and in Inside Macintosh: Text, this bit doesnÕt have any influence on inline input done with the Text Services Manager and TSMTE. It was used by the extension that provided inline input for TextEdit in KanjiTalk 6.0.7.Preparing to Use TSMTEStarting from this section, we assume that you have a good understanding of the high-level routines of the Text Services Manager. You can find the necessary information in Inside Macintosh: Text, pages 7-17 to 7-24. Please make sure to read the section ÒMore Inline Input AdviceÓ at the end of this Technical Note for additional hints on how to successfully use the Text Services Manager and input methods.Defining the Level of Functionality You NeedYour application can provide several different kinds of text editing functionality, and your usage of TSMTE and the Text Services Manager depends on which one you offer. Your application may support text input:1)	in modal dialogs (which use TextEdit)2)	in document windows using TextEdit and in modeless dialogs3)	in windows using your own text engineplus in any combination thereof.The rest of this section discusses the steps you have to take to prepare your application to use TSMTE in any possible context. The following sections then look at the individual cases.Testing for TSMTEBefore making calls for TSMTE, you have to check for its presence using Gestalt. The selector for TSMTE is gestaltTSMTEAttr, and you know that it is available if the gestaltTSMTEPresent bit in the response is set.The following code initializes separate Boolean variables to indicate the presence of the Text Services Manager and TSMTE. Having separate variables is useful if you use your own text engine in addition to TextEdit and want to support inline input for that engine even if TSMTE is not present.static void CheckForTextServices(void){	long gestaltResponse;		gHasTextServices = false;		// unless proven otherwise	gHasTSMTE = false;			// unless proven otherwise		if (TrapAvailable(_Gestalt))	{		if ((Gestalt(gestaltTSMgrVersion, &gestaltResponse) == noErr) &&			 (gestaltResponse >= 1))		{			gHasTextServices = true;			if (Gestalt(gestaltTSMTEAttr, &gestaltResponse) == noErr)				gHasTSMTE = BTst(gestaltResponse, gestaltTSMTEPresent);		};	};}Initializing and Closing the Text Services ManagerTo enable inline input, you have to initialize the Text Services Manager by calling InitTSMAwareApplication in your initialization sequence, and close it before quitting by calling CloseTSMAwareApplication. But what if TSMTE is not available? Then you have to make the floating input window available to the user for entering text in a 2-byte script into a TextEdit field. How to do this depends on whether you use your own text engine in addition to TextEdit (we assume that your own text engine supports inline input Ğ otherwise you probably would not think about adding inline input support to TextEdit).If you only use TextEdit in your application, you simply call InitTSMAwareApplication only if TSMTE is available. If you donÕt call InitTSMAwareApplication, system software will automatically handle input in 2-byte scripts for your application in a floating input window. The following code performs the initialization and also shows how to move on without text services if InitTSMAwareApplication fails:if (!(gHasTSMTE && InitTSMAwareApplication() == noErr)){	// if this happens, just move on without text services	gHasTextServices = false;	gHasTSMTE = false;};If you use your own text engine in addition to TextEdit and support inline input for it, you want to use inline input for your engine even if TSMTE is not available. To do this, you simply check gHasTextServices instead of gHasTSMTE in the first line of the code above. Later, you also have to make sure that you tell the Text Services Manager to use the floating input window whenever a TextEdit field is active Ğ the section ÒUsing TSMTE and TextEdit in Addition to Your Own Text EngineÓ discusses this in detail.In either case, you have to call CloseTSMAwareApplication before quitting an application for which you successfully called InitTSMAwareApplication:if (gHasTextServices)	(void) CloseTSMAwareApplication();ExitToShell();Using TSMTE for Modal DialogsOnce you have initialized the Text Services Manager, TSMTE offers a very easy way to handle inline input for modal dialogs: you set the refCon field in the DLOG resource to kTSMTEDialog or kTSMTEInterfaceType, TSMTE handles the rest. Or, if circumstances force you to create a dialog programmatically, you can pass kTSMTEInterfaceType as the refCon argument to NewDialog or NewCDialog (these routines do not accept kTSMTEDialog). Either way, TSMTE will automatically create a TSMDocument for you, activate and deactivate the TSMDocument, and enable inline input for the dialog. When you call CloseDialog or DisposeDialog, TSMTE disposes of the TSMDocument it created, activates the TSMDocument that was active before opening the dialog (if there was one), and resets the Text Services Manager flag that determines whether to use the floating input window to its previous state.Note:	If you use this feature, you can still use the refCon field for your own purposes after creating the dialog Ğ TSMTE doesnÕt need it any longer.The difference between the two constants is that kTSMTEInterfaceType tells TSMTE to use an extended dialog record, TSMDialogRecord, while kTSMTEDialog uses the standard dialog record. Using the extended dialog record lets you access the information that TSMTE uses if you need it; without it, the information is stored in TSMTEÕs private data structures. If you use kTSMTEInterfaceType but donÕt provide storage for the dialog record, the Dialog Manager routines will automatically allocate an extended record.If you use kTSMTEInterfaceType and allocate your own storage or add your own fields to the dialog record, you have to take the additional 20 bytes of the extended dialog record into account. If you add your own fields, itÕs a good idea to also allocate your own storage. This way you can always include the fields for TSMTE, otherwise the location of your fields in the record depends on whether TSMTE is installed or not.If you provide an event filter function for ModalDialog, TSMTE gives you the choice whether you want to handle Text Services Manager calls or whether TSMTE should do it. To determine whether the function handles the calls, TSMTE calls it with a null event. If the function calls TSMEvent, TSMTE assumes that the function makes all the necessary calls to the Text Services Manager. If it doesnÕt, or if there is no event filter function, TSMTE makes all the necessary calls itself.While using inline input, ModalDialog doesnÕt return because it doesnÕt get to see any ÒrealÓ events. If you have a dialog that opens with a disabled action button and waits for the user to type text into an editable text item before enabling the button, checking the editable text item only after ModalDialog returns does not have the desired effect Ğ if the user uses inline input to enter text, the button doesnÕt get enabled. A solution for this is to use an event filter function that checks the text in the editable text item and enables the button if the text length is above zero. The event filter function is guaranteed to be called with a null event whenever TSMEvent consumes a keyDown event.Using TSMTE for Document Windows and for Modeless DialogsIf you use TextEdit to edit text in document windows or if you use modeless dialogs, some more work is shifted over to you: now it becomes your responsibility to call the high-level Text Services Manager routines. YouÕll have to add calls to:NewTSMDocumentDeleteTSMDocumentActivateTSMDocumentDeactivateTSMDocumentTSMEventTSMMenuSelectSetTSMCursorFixTSMDocumentBefore making the Text Services Manager calls, you have to make sure that their preconditions are met. You only want to create a TSM document for a TextEdit text record if TSMTE is available. You only want to delete, activate, or deactivate, or confirm (ÒfixÓ) a TSM document if creating it was successful. The remaining routines depend on the Text Services Manager being available, but not necessarily on TSMTE Ğ you may be using your own text engine with inline input in addition to TextEdit. The variables gHasTextServices and gHasTSMTE introduced above can help you make the necessary decisions. For example, your menu handling code might look like this:menuResult = MenuSelect(event->where);if (!(gHasTextServices && TSMMenuSelect(menuResult)))	DoMenuCommand(menuResult);HiliteMenu(0);The usage of Text Services Manager routines is documented in Inside Macintosh: Text, so weÕll discuss only how TSMTE extends the Text Services Manager interface.Creating a TSM DocumentWhen creating a TSMDocument for a TextEdit text record, you have to use a special interface type kTSMTEInterfaceType to indicate that TSMTE should handle Apple events for this TSM document.If you pass kTSMTEInterfaceType to NewTSMDocument, the refCon argument takes on a different meaning. Instead of a value to be stored in the TSM document, you should pass in the address of a variable of type TSMTERecHandle. TSMTE allocates a data structure of type TSMTERec and assigns a handle to it to your variable. This data structure contains several fields that you can use to tailor TSMTEÕs behavior to the needs of your application. It is your applicationÕs responsibility to initialize the record.struct TSMTERec {	TEHandle					textH;	TSMTEPreUpdateUPP		preUpdateProc;	TSMTEPostUpdateUPP	postUpdateProc;	long						updateFlag;	long						refCon;};The textH field has to be set to the text record handle that this TSM document relates to.In preUpdateProc and postUpdateProc you can specify call-back routines that TSMTE should call before and after its own code when handling the Update Active Input Area event (one of the Apple events that is sent by the input method). The interfaces and possible uses for both routines are described below. If you donÕt have routines that TSMTE should call, set the fields to nil.The updateFlag field is intended for customization of TSMTEÕs behavior. The idea is that TSMTE can define several constants for variations in its behaviors, and you sum up the constants for the variations that you like and assign them to the updateFlag field. Currently, only one such constant, kTSMTEAutoScroll, is defined. It specifies that TSMTE automatically scrolls the selection range into view. If you set updateFlag to 0, automatic scrolling is disabled, and you have to scroll the text yourself, e.g., in one of the call-back routines.The refCon field lets you specify a value that TSMTE will pass on to the call-back routines. TSMTE doesnÕt make any other use of this field.Here is some sample code for creating a TSMDocument. It assumes that you have just created a TEHandle called docTEHandle, and that a Boolean variable good is used to indicate whether operations are successful, and that you want to pass a pointer to the document window to your call-back routine.if (good && gHasTSMTE){	supportedInterfaces[0] = kTSMTEInterfaceType;	if (NewTSMDocument(1, supportedInterfaces, &doc->docTSMDoc,				(long) &doc->docTSMTERecHandle) == noErr)	{		TSMTERecPtr tsmteRecPtr = *(doc->docTSMTERecHandle);				tsmteRecPtr->textH = doc->docTE;		tsmteRecPtr->preUpdateProc = gTSMTEPreUpdateUPP;		tsmteRecPtr->postUpdateProc = gTSMTEPostUpdateUPP;		tsmteRecPtr->updateFlag = kTSMTEAutoScroll;		tsmteRecPtr->refCon = (long) window;	}	else		good = false;};You shouldnÕt dispose of the TSMTERecHandle Ğ DeleteTSMDocument will do this for you.Using a Pre-Update Call-Back RoutinePre-update call-back routines for TSMTE have the following interface:pascal void MyTSMTEPreUpdateProc(TEHandle textH, long refCon);If you provide a pre-update routine for a TSM document, it is called before TSMTEÕs code for handling the Update Active Input Area events relating to this document.The values for the textH and refCon arguments are taken from the TSMTERecHandle of the TSM document.One common use of the pre-update routine is to save information that will be needed for Undo and Redo. Without inline input, an application typically treats an uninterrupted sequence of keyDown events (other than arrow or function keys) as one action, and saves the currently selected text and related information when receiving the first event in this sequence. In this regard, you should treat a call to your pre-update routine as just another form of typing, and if itÕs the first one in a typing sequence, save the information for Undo.Another use is to work around a bug in TSMTE 1.0, which doesnÕt always synchronize the font to be used with the current keyboard script. The following routine checks whether the current font can display the incoming characters, and if not, sets the font to the keyboard scriptÕs application font. A better solution would be to scan the text backwards for the most recently used font of the keyboard script. This solution will be used by future versions of TSMTE, so make sure to check the TSMTE version and use the workaround only for TSMTE 1.0, as shown below. The synchronization is only necessary when a new active input area is created, so you may want to use the post-update routine to track whether there is an active input area and only execute the font synchronization code when the pre-update routine is called while thereÕs no active input area.static pascal void MyTSMTEPreUpdateProc(TEHandle textH, long refCon){	long response;	ScriptCode keyboardScript;	short mode;	TextStyle theStyle;		if ((Gestalt(gestaltTSMTEVersion, &response) == noErr) &&		 (response == gestaltTSMTE1))	{		keyboardScript = GetScriptManagerVariable(smKeyScript);		mode = doFont;		if (!(TEContinuousStyle(&mode, &theStyle, textH) &&				FontToScript(theStyle.tsFont) == keyboardScript))		{			theStyle.tsFont = GetScriptVariable(keyboardScript, smScriptAppFond);			TESetStyle(doFont, &theStyle, false, textH);		};	};}Note:	Depending on which interface files you use, you may have to use the old name GetEnvirons instead of the new GetScriptManagerVariable, because thereÕs no correct declaration for the new name. The universal interfaces have a correct declaration.If your application occasionally changes the origin of the TextEdit recordÕs grafPort, you can also use the pre-update routine to reset the origin so that characters get drawn in the right location.Using a Post-Update Call-Back RoutinePost-update call-back routines for TSMTE have the following interface:pascal void MyTSMTEPostUpdateProc(TEHandle textH, long fixLen,			long inputAreaStart, long inputAreaEnd,			long pinStart, long pinEnd, long refCon);If you provide a post-update routine for a TSM document, it is called after TSMTEÕs code for handling Update Active Input Area events relating to this document. If you have set the updateFlag field in the TSMTERec record to kTSMTEAutoScroll, TSMTE calls the call-back routine first, and then scrolls the selection range into view.The values for the textH and refCon arguments are taken from the TSMTERecHandle of the TSM document. InputAreaStart and inputAreaEnd are the offsets of the start and end of the active input area relative to the entire text handle; they are both set to -1 if there is no active input area. The remaining parameters are a subset of the parameters for the Update Active Input Area event. The fixLen parameter is the length of the confirmed text. PinStart and pinEnd are the offsets of the start and end of the text range that should be in view.Common uses of the post-update routine are:¥	adjusting scroll bars or input field widths to the width and height of the text, which may have changed during editing,¥	setting a ÒmodifiedÓ flag for the document,¥	saving information about the text being entered for Undo and Redo,¥	keeping track of whether thereÕs an active input area.Calling FixTSMDocumentThe FixTSMDocument routine should be called whenever the user switches from typing to a different kind of activity that operates on the text, e.g., initiating an editing command from the menu or selecting text. It should not be called for actions that would not be considered interrupting a typing sequence, e.g., resizing or scrolling the window. There are some actions in between for which we donÕt have clear guidelines yet; in these cases use your best judgment.TSMTE will in some cases detect that FixTSMDocument needs to be called and do it for you, e.g., when the user clicks into a part of the document outside the input area. In most cases however it is your responsibility to call FixTSMDocument when appropriate: when the user selects an editing command from the menu, closes a document, saves or prints it.Using TSMTE and TextEdit in Addition to Your Own Text EngineIf you use your own text engine in addition to TextEdit, you will have to provide your own Apple event handlers for the Text Services Apple events to implement inline input for your engine. However, you can still use TSMTE to provide inline input wherever you use TextEdit in your application.Your Apple event handlers donÕt need to worry about TextEdit at all. TSMTE installs its event handlers in the system heap, so you can install your handlers in the application heap. The supported interface type that you specify when you create a TSM document is used to arbitrate between the handlers: for TSM documents that were created with kTSMTEInterfaceType, the TSMTE handlers are called, for those that  were created with kTextService, your handlers.The only thing you have to worry about is what to do if the Text Services Manager is available, but not TSMTE, so that you can provide inline input for your engine, but not for TextEdit. In this case you want to make sure that inline input is used whenever your engine is active, but that a floating input window is made available whenever a TextEdit field is active (without the floating input window users would not be able to type anything meaningful in a 2-byte script). You can do this by calling UseInputWindow whenever you activate or deactivate a TextEdit record Ğ here is sample code for activation:if (doc->docTSMDoc != nil)	CheckError(ActivateTSMDocument(doc->docTSMDoc));else	CheckError(UseInputWindow(nil, true));More Inline Input AdviceThis section contains some information that is not specific to TSMTE, but applies to all applications that use the Text Services Manager in any form. It shows workarounds for some unexpected features (we wonÕt use entomological terminology hereÉ) in the Text Services Manager and first-generation input methods written for it. Some of those unexpected features are expected to be or have already been discontinued in newer versions.Incorrect Declaration in TextServices.pThe Text Services interface file TextServices.p that is currently distributed on E.T.O. 12 and the November 1993 Developer CD contains an incorrect declaration for NewTSMDocument. The declaration should read:Function NewTSMDocument(numOfInterface: Integer;		VAR supportedInterfaceTypes: InterfaceTypeList; VAR idocID: TSMDocumentID; 		refCon: Longint): OSErr;	INLINE $303C, $0000, $AA54;Without the keyword ÒvarÓ in front of ÒsupportedInterfaceTypesÓ, your application will encounter a bus error in NewTSMDocument. So, go in and add the keyword ÒvarÓ if itÕs not there.The declaration for NewTSMDocument in TextServices.h is correct.DeleteTSMDocument Uses Disposed HandleIf a TSMDocument is deleted without being deactivated first, the routine DeleteTSMDocument may reuse a handle that it has already disposed of. It dereferences this handle and writes a single byte. This may eventually cause your application to crash mysteriously.Workaround: make sure to deactivate each TSM document using DeactivateTSMDocument before calling DeleteTSMDocument to delete it. If TSMTE calls DeleteTSMDocument for a TSM document it created for a modal dialog it does the right thing.ActivateTSMDocument Must Be Called From ForegroundActivateTSMDocument does not work properly if called from the background. When a window that owns a TSM document is coming to the foreground from the background, your application is supposed to call ActivateTSMDocument with the TSMDocumentID for that window.  However, if your application makes this call while still in the background, inline input may not become re-enabled in that window. Applications that follow the usual scheme of activating windows after receiving an activate event shouldnÕt have any problems.SetTSMCursor and Cursor RegionsApplications that use TSM are supposed to call SetTSMCursor generously in order to allow TSM components to set the cursor when they need to do so. Unfortunately, there is no protocol for finding out in which region the input method would want to set the cursor. This presents a problem for many applications that try to be cooperative by passing a cursor region to WaitNextEvent. Without information from the input method, an application using inline input cannot calculate a meaningful cursor region, and thus has to be run whenever the mouse moved.The only thing you can currently do is to define a 1-pixel cursor region under the mouse point and pass this region to WaitNextEvent. This setup will cause mouse-moved events to be generated whenever the mouse is moved, but will let the application sleep if the mouse stays put.Strange Delete Key BehaviorIf you use Kotoeri, AppleÕs Japanese input method, you may notice that deletion of Japanese characters in the active input area using the delete character does not work properly in your application. This is more likely to happen with styled text or on non-Japanese system software (e.g., with the Japanese Language Kit installed). Kotoeri thinks that it is using a Roman font and only deletes one byte for each delete key pressed. This results in the need to press the delete key twice to delete a single Japanese character as well as other strange inline behavior.Workaround: Add some code around your call to TSMEvent that sets the font in the current grafPort to one of the keyboard script, and resets it afterwards if necessary. KotoeriÕs behavior depends on the font in the current grafPort that it encounters during your call to TSMEvent. Here is a routine that you can call instead of TSMEvent to accomplish this:static Boolean IntlTSMEvent(EventRecord *event){	short oldFont;	ScriptCode keyboardScript;		if (qd.thePort != nil)	{		oldFont = qd.thePort->txFont;		keyboardScript = GetScriptManagerVariable(smKeyScript);		if (FontToScript(oldFont) != keyboardScript)			TextFont(GetScriptVariable(keyboardScript, smScriptAppFond));	};	return TSMEvent(event);}You should also make sure that the current grafPort at this point is the one in which the input will be displayed. Pascal SummaryConstantsconst	{ signature, interface types }		kTSMTESignature = 'tmTE';	kTSMTEInterfaceType = kTSMTESignature;	kTSMTEDialog = 'tmDI';		{ Gestalt }		gestaltTSMTEAttr = kTSMTESignature;	gestaltTSMTEPresent = 0;	gestaltTSMTEVersion = 'tmTV';	gestaltTSMTE1 = $0100;	{ update flag for TSMTERec }	kTSMTEAutoScroll = 1;Data Typestype	TSMTERec = record		textH:				TEHandle;		preUpdateProc:		ProcPtr;		postUpdateProc:	ProcPtr;		updateFlag:			Longint;		refCon:				Longint;		end;		TSMTERecPtr = ^TSMTERec;	TSMTERecHandle = ^TSMTERecPtr;	TSMDialogRecord = record		fDialog:				DialogRecord;		fDocID:				TSMDocumentID;		fTSMTERecH:			TSMTERecHandle;		fTSMTERsvd:			array [0..2] of Longint;		end;	TSMDialogPeek = ^TSMDialogRecord;Application-Defined Routinesprocedure MyTSMTEPreUpdateProc(textH: TEHandle; refCon: Longint);procedure MyTSMTEPostUpdateProc(textH: TEHandle; fixLen: Longint;		inputAreaStart, inputAreaEnd: Longint;		pinStart, pinEnd: Longint; refCon: Longint);C SummaryConstants// signature, interface typesenum  {	kTSMTESignature		= 'tmTE',	kTSMTEInterfaceType	= kTSMTESignature,	kTSMTEDialog			= 'tmDI'};// Gestaltenum  {	gestaltTSMTEAttr		= kTSMTESignature,	gestaltTSMTEPresent	= 0,	gestaltTSMTEVersion	= 'tmTV',	gestaltTSMTE1			= 0x100};// update flag for TSMTERecenum  {	kTSMTEAutoScroll		= 1};Data Types// the following proc ptr declarations come with the usual complements of// universal proc ptr declarations and related routinestypedef pascal void (*TSMTEPreUpdateProcPtr)(TEHandle textH, long refCon);typedef pascal void (*TSMTEPostUpdateProcPtr)(TEHandle textH, long fixLen,		long inputAreaStart, long inputAreaEnd,		long pinStart, long pinEnd, long refCon);struct TSMTERec {	TEHandle					textH;	TSMTEPreUpdateUPP		preUpdateProc;	TSMTEPostUpdateUPP	postUpdateProc;	long						updateFlag;	long						refCon;};typedef struct TSMTERec TSMTERec, *TSMTERecPtr, **TSMTERecHandle;struct TSMDialogRecord {	DialogRecord			fDialog;	TSMDocumentID			fDocID;	TSMTERecHandle			fTSMTERecH;	long						fTSMTERsvd[3];};typedef struct TSMDialogRecord TSMDialogRecord, *TSMDialogPeek;Application-Defined Routinespascal void MyTSMTEPreUpdateProc(TEHandle textH, long refCon);pascal void MyTSMTEPostUpdateProc(TEHandle textH, long fixLen,		long inputAreaStart, long inputAreaEnd,		long pinStart, long pinEnd, long refCon);Further Reference:¥	Inside Macintosh: Text, Text Services Manager¥	Sample Code: ÒInlineInputSampleÓ’    ×# ÿ ÿÿÿÿ        #  ×         ‚      
 / Z #       
 	0Iˆ:µœğ9 " {   	ÿÿÿÿÿÿÿÿ #     Ä ¡ d 
ONLN f  ş   Œ ¡ d 1drw2 É -á_  €                 ÿÿÿÿÿÿ        ¡ –    x       ¡ d drw2 :         ¡ d drw2 :  $     ¡ d 4drw2 :                                       ¡ š ÿú   —@    ˜ ,  Times       .      RÉ RÉ +]BNew Technical Notes   ™ ¡ d drw2 :  ¡ã     — ¡ d 1drw2 eô  €                 ÿÿÿÿÿÿ   P     ¡ –    x       ¡ d drw2 :         ¡ d drw2 :  $     ¡ d 4drw2 :                                        ¡ š ÿû€  EÀ    ˜      ¡ d ONLN dÿÿ         ( {•Developer Support   ™ ¡ d drw2 :  ¡ã     — ¡ d `drw2   - ï                  ÿÿÿÿÿÿ  K     ï  -                Z                    f f Z ¡ d 1drw2 ÊÀúé                    ÿÿÿÿÿÿ   K     ¡ –    x       ¡ d drw2 :         ¡ d drw2 :  $     ¡ d 4drw2 :     0                                   ¡ š ÿô   €    ˜  0 ( Uïğ   ™ ¡ d drw2 :  ¡ã     — ¡ d 1drw2 ïæúğ                    ÿÿÿÿÿÿ         ¡ –    x       ¡ d drw2 :         ¡ d drw2 :  $     ¡ d 4drw2 :     	                                   ¡ š ÿı€       ˜  	 ¡ d ONLN dÿÿ         +&	¨   ™ ¡ d drw2 :  ¡ã     — ¡ d 1drw2 å -ø y                    ÿÿÿÿÿÿ       ¡ –    x       ¡ d drw2 :         ¡ d drw2 :  $     ¡ d 4drw2 :                                        ¡ š ÿû€  %     ˜   ¡ d ONLN dÿÿ         ( Z \	Macintosh   ™ ¡ d drw2 :  ¡ã     —    ¡ d drw2 D   ƒ  
    IR   .           ¡ d ONLN dÿÿ         ( › Z,TE 27 Ğ Inline Input for TextEdit with TSMTE    ¡ d ONLN dÿÿ         *Text      ¡ d ONLN dÿÿ         *Written by:  ¡ d ONLN dÿÿ         )H,Yasuo Kida, Keisuke Hara, Nobuhiro Miyatake, ¡ d ONLN dÿÿ         ( ÃÒDecember 1993 ¡ d ONLN dÿÿ         ( Ï ¢ Peter Sparks, Norbert Lindenberg      ¡ d ONLN dÿÿ         ( ç Z2This Technical Note describes TSMTE, an extension       ¡ d ONLN dÿÿ         ( ç](that simplifies implementation of inline      ¡ d ONLN dÿÿ         ( ó ZEinput for TextEdit using the Text Services Manager in System 7.1 and      ¡ d ONLN dÿÿ         ( ó³later, and shows you       ¡ d ONLN dÿÿ         ( ÿ ZNhow to make the best use of it. It also contains some advice for working with       ¡ d ONLN dÿÿ         ( ÿÉthe Text Services      ¡ d ONLN dÿÿ         ( ZNManager that applies to any application using TSM, not just those using TSMTE.    ¡ d ONLN dÿÿ         *Topics    ¡ d ONLN dÿÿ         +¥ What is TSMTE ¡ d ONLN dÿÿ         *"¥ Where and how is TSMTE delivered ¡ d ONLN dÿÿ         *%¥ How is TSMTE used in an application  ¡ d ONLN dÿÿ         *3¥ Advice for working with the Text Services Manager      b Xb     ¡ d ONLN dÿÿ         (‡ ZIntroduction           ¡ d ONLN dÿÿ         *HSystem 7.1 introduced a new Toolbox manager, the Text Services Manager,      ¡ d ONLN dÿÿ         (ŸÛthat makes it      ¡ d ONLN dÿÿ         (« Zeasier for      ¡ d ONLN dÿÿ         )/Dapplications to provide inline input for 2-byte script systems (see    ¡ d ONLN dÿÿ         («ÇInside Macintosh:      ¡ d ONLN dÿÿ         (· ZText     ¡ d ONLN dÿÿ         ), pages 7-6      ¡ d ONLN dÿÿ         )8Lto 7-12, for an overview). To implement inline input using the Text Services      ¡ d ONLN dÿÿ         (Ã ZEManager, an application has to do two things: make some calls to the      ¡ d ONLN dÿÿ         (Ã¡Text Services Manager in       ¡ d ONLN dÿÿ         (Ï Z
the right       ¡ d ONLN dÿÿ         )*Rplaces, and provide Apple event handlers that respond to events from input methods     ¡ d ONLN dÿÿ         (Û Z"by updating text data structures,       ¡ d ONLN dÿÿ         )©8displaying text, and translating text offsets and screen     ¡ d ONLN dÿÿ         (ç Z$coordinates. The first part is easy       ¡ d ONLN dÿÿ         )²2(maybe 50-100 lines of code), the second part can,      ¡ d ONLN dÿÿ         (ó Zdepending on the complexity of      ¡ d ONLN dÿÿ         )˜?the text engine that you use, require substantial work (several       ¡ d ONLN dÿÿ         (ÿ Z'hundred to thousands of lines of code). ¡ d ONLN dÿÿ         *ATSMTE is an extension to the Text Services Manager that does the       ¡ d ONLN dÿÿ         (–second part of the work for      ¡ d ONLN dÿÿ         (# Zyou if      ¡ d ONLN dÿÿ         )Wyou use TextEdit. It provides Apple event handlers that handle all interactions between  ¡ d ONLN dÿÿ         (/ Z;an input method and TextEdit. The handlers are kept in the      ¡ d ONLN dÿÿ         (/|system heap, so they are shared      ¡ d ONLN dÿÿ         (; Zbetween all applications. ¡ d ONLN dÿÿ         *GTSMTE thus can reduce the effort needed to implement inline input to a       ¡ d ONLN dÿÿ         (S­day or two. If you use      ¡ d ONLN dÿÿ         (_ Z+TextEdit in documents or modeless dialogs,      ¡ d ONLN dÿÿ         )Ş(you have to make a few calls to TSMTE in      ¡ d ONLN dÿÿ         (k Zexchange for its help; if you       ¡ d ONLN dÿÿ         )‡?use TextEdit only in modal dialogs, you only have to modify the       ¡ d ONLN dÿÿ         (w Z DLOG resources that define them.      ¡ d ONLN dÿÿ         *AIf you use a text engine other than TextEdit for editing in your       ¡ d ONLN dÿÿ         (application, you can still use       ¡ d ONLN dÿÿ         (› ZITSMTE to handle inline input wherever you use TextEdit, e.g., in dialogs.  Á XÁ  
 *;,TE 27 Ğ Inline Input for TextEdit with TSMTE (Öÿ1 ) of 13 (ì ZM.TE.Inline Input for TextEdit  ÿ ¡ Àô%%DSIDICT:_cvcurrentdict /bu known {bu}ifuserdict /_cv known not{userdict /_cv 30 dict put}if_cv begin/bdf{bind def}bind defcurrentscreen/cs exch def/ca exch def/cf exch def/setcmykcolor where{/setcmykcolor get /cvcmyk exch def}{/cvcmyk{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll}repeat setrgbcolor pop}bdf }ifelse/ss{//cf //ca //cs setscreen}bdf/stg{ss setgray}bdf/strgb{ss setrgbcolor}bdf/stcmyk{ss cvcmyk}bdf/min1{dup 0 eq{pop 1}if}bdfendcurrentdict /bn known {bn}if   ¿N    ×# ÿ ÿÿÿÿ        #  ×            
    IR ,  Times    
 .      +6-Macintosh Technical Notes   / 4 /ù     *Note:         )$KanjiTalk 6.0.7 had an       )y3extension that provided fully automatic support for      ( Q Z#inline input with TextEdit without      )¬)any kind of modification to applications.      ( ] ZWith TSMTE, inline      )g6input is not quite so automatic Ğ you have to make the      ( i ZGnecessary calls to TSMTE and the Text Services Manager to make it work.   ¡ d ONLN dÿÿ         (  6Note:        ¡ d ONLN dÿÿ         )$DInside Macintosh: Text, pages 2-107 to 2-109, discusses two feature      ¡ d ONLN dÿÿ         ( ¿bits,      ¡ d ONLN dÿÿ         (  ZteFUseTextServices and      ¡ d ONLN dÿÿ         )v3teFInlineInput. TeFUseTextServices doesnÕt have any  ¡ d ONLN dÿÿ         ( ™ Z9impact on the Text Services Manager or TSMTE, so you can      ¡ d ONLN dÿÿ         ( ™†safely ignore it.      ¡ d ONLN dÿÿ         ( ¥ ZLTeFInlineInput is handled by TSMTE, so there is no need for you to touch it.      ¡ d ONLN dÿÿ         ( Ì 6TSMTE Overview    ¡ d ONLN dÿÿ         *Availability        ¡ d ONLN dÿÿ         *4Currently, TSMTE is delivered as a system extension      ¡ d ONLN dÿÿ         ( ü=%called ÒInline Tuika KinouÓ, which is      ¡ d ONLN dÿÿ         ( 6shown here:   ¡ d ONLN dÿÿ         +ªH   
# äPN ™€( °U         H   H           A>t      ”     ÿÿÿÿÿÿ       ( °U# äPN   
# äPN	ı ÿÿşû 	ı   û 	ı   û 	ı   û 	ı   û 	ı ?üû 	ı  û 	ı  û 	ı  û 
ı  A@ü 
ı  á ü 
ı   ! ü 
ı '»  ü 
ı     ü 
ı     ü 
ı 'w  ü 
ı     ü 
ı  |  ü 
ı 'b  ü 
ı  C  ü 
ı  B¡ ü 
ı  Ea ü 
ı  8¡@ü 	ı  Qû 	ı  
)û 	ı ?ıû 	ı  û 	ı  Eû 	ı   ©û 	ı   qû 	ı   û 	ı ÿÿşû ó ó 
ú  @¤D   ?  ü@(D€ş  ` …ûÜ¤—   @€üJE)ô@ €À œ€JM¬À4  ƒ@üJL ğ Ä @„JUü”€   @„JT ÷  À @üŠD””  0 @p
 ŠEXô@
ú ı3Å$—À  
    IR ¡ d ONLN dÿÿ         (e *Figure 1ĞInline Tuika Kinou extension file         ¡ d ONLN dÿÿ         (} 6If you look for this      ¡ d ONLN dÿÿ         )bCfile while running system software in some language using the Roman       ¡ d ONLN dÿÿ         (Š 6Dscript system, the name of the extension file will be displayed as Ò  , 	 Geneva     	 ¡ d ONLN dÿÿ         (ŠmƒCƒ“ƒ‰ƒCƒ“’Ç‰Á‹@”\      ¡ d ONLN dÿÿ         )ZÓ. ¡ d ONLN dÿÿ         (¢ 6The extension is part of the      ¡ d ONLN dÿÿ         )ƒBJapanese version of System 7.1, KanjiTalk 7. It is not part of the ¡ d ONLN dÿÿ         (® 6Japanese Language Kit       ¡ d ONLN dÿÿ         )sAor of any other version of System 7.1. This means that if you use  ¡ d ONLN dÿÿ         (º 6)TSMTE to implement inline input, it will      ¡ d ONLN dÿÿ         )Ñ/currently only benefit users of Japanese system       ¡ d ONLN dÿÿ         (Æ 6-software. However, TSMTE may get rolled into      ¡ d ONLN dÿÿ         )ç-a future version of the base system software,  ¡ d ONLN dÿÿ         (Ò 6so      ¡ d ONLN dÿÿ         )Vthat it would then be available for use with any 2-byte script system on any Macintosh      ¡ d ONLN dÿÿ         (Ş 6<worldwide. Your application should therefore use Gestalt to       ¡ d ONLN dÿÿ         (ŞTcheck for the presence of TSMTE      ¡ d ONLN dÿÿ         (ê 6$and use it whenever it is available.  ¡ d ONLN dÿÿ         *>For development purposes, if you donÕt feel comfortable using      ¡ d ONLN dÿÿ         (bJapanese system software, you     ¡ d ONLN dÿÿ         ( 6Pcan install the Japanese Language Kit and the Inline Tuika Kinou extension into       ¡ d ONLN dÿÿ         (×system  ¡ d ONLN dÿÿ         ( 6software in any       ¡ d ONLN dÿÿ         )XClanguage that you like. Apple does not exactly guarantee that these      ¡ d ONLN dÿÿ         (& 6configurations will work,       ¡ d ONLN dÿÿ         )@but our experience so far has been good. Final testing should of     ¡ d ONLN dÿÿ         (2 6Rcourse be done on a real Japanese system. In order to get your application to use       ¡ d ONLN dÿÿ         (2Ä
a Japanese      ¡ d ONLN dÿÿ         (> 6Qfont in dialogs or in documents where you donÕt allow the user to select a font,      ¡ d ONLN dÿÿ         (>½you have to      ¡ d ONLN dÿÿ         (J 6register your       ¡ d ONLN dÿÿ         )?Oapplication as Japanese using the Language Register application that comes with       ¡ d ONLN dÿÿ         (V 6the Japanese Language Kit.    ¡ d ONLN dÿÿ         *Limitations     ¡ d ONLN dÿÿ         *"You may find that with some fonts      ¡ d ONLN dÿÿ         )§8TSMTE truncates the lower portion of characters drawn in ¡ d ONLN dÿÿ         (’ 6\the input area because it reserves a two-pixel high area for underlining. This problem will       ¡ d ONLN dÿÿ         (’íbe       ¡ d ONLN dÿÿ         ( 6fixed in a future release.   Á 4Áù  
 *82  ) of 13 )ş,TE 27 Ğ Inline Input for TextEdit with TSMTE +BM.TE.Inline Input for TextEdit  ÿH    ×# ÿ ÿÿÿÿ        #  ×            
    IR ,  Times    
 .      +Z-Developer Support Center  ( -ŞDecember 1993   / X /     ( E ZPrerequisites    *!To use the Text Services Manager       )£8and TSMTE, your application has to support Apple events.      ( i Z(This means that it has to install Apple       )³:event handlers at least for the four required event types,      ¡ d ONLN dÿÿ         ( u ZEand has to set the isHighLevelEventAware bit in the SIZE -1 resource.   ¡ d ONLN dÿÿ         *Note:         ¡ d ONLN dÿÿ         )$	The SIZE       ¡ d ONLN dÿÿ         )9<resource also has a useTextEditServices bit. Contrary to the     ¡ d ONLN dÿÿ         ( ™ ~comments in Types.r and in    ¡ d ONLN dÿÿ         )ŒInside Macintosh: Text    ¡ d ONLN dÿÿ         )n, this bit doesnÕt       ¡ d ONLN dÿÿ         )Thave any      ¡ d ONLN dÿÿ         ( ¥ ~
influence       ¡ d ONLN dÿÿ         ).Aon inline input done with the Text Services Manager and TSMTE. It       ¡ d ONLN dÿÿ         ( ± ~was       ¡ d ONLN dÿÿ         )Jused by the extension that provided inline input for TextEdit in KanjiTalk      ¡ d ONLN dÿÿ         ( ½ ~6.0.7.      ¡ d ONLN dÿÿ         ( ä ZPreparing to Use TSMTE           ¡ d ONLN dÿÿ         *+Starting from this section, we assume that       ¡ d ONLN dÿÿ         )Ğ/you have a good understanding of the high-level  ¡ d ONLN dÿÿ         ( Zroutines of the Text      ¡ d ONLN dÿÿ         )g<Services Manager. You can find the necessary information in    ¡ d ONLN dÿÿ         (ÿInside       ¡ d ONLN dÿÿ         ( ZMacintosh: Text    ¡ d ONLN dÿÿ         )L, pages 7-17       ¡ d ONLN dÿÿ         )>@to 7-24. Please make sure to read the section ÒMore Inline Input ¡ d ONLN dÿÿ         (  ZVAdviceÓ at the end of this Technical Note for additional hints on how to successfully       ¡ d ONLN dÿÿ         ( ùuse the      ¡ d ONLN dÿÿ         (, Z(Text Services Manager and input methods.    ¡ d ONLN dÿÿ         *,Defining the Level of Functionality You Need        ¡ d ONLN dÿÿ         *=Your application can provide several different kinds of text       ¡ d ONLN dÿÿ         (\„editing functionality, and your     ¡ d ONLN dÿÿ         (h Z-usage of TSMTE and the Text Services Manager      ¡ d ONLN dÿÿ         )ø$depends on which one you offer. Your      ¡ d ONLN dÿÿ         (t Z#application may support text input: ¡ d ONLN dÿÿ         *1) ¡ d ONLN dÿÿ         )%in modal dialogs (which use TextEdit)  ¡ d ONLN dÿÿ         (Œ Z2)  ¡ d ONLN dÿÿ         ):in document windows using TextEdit and in modeless dialogs ¡ d ONLN dÿÿ         (˜ Z3)  ¡ d ONLN dÿÿ         )%in windows using your own text engine  ¡ d ONLN dÿÿ         (¤ Z plus in any combination thereof.  ¡ d ONLN dÿÿ         *#The rest of this section discusses       ¡ d ONLN dÿÿ         )=the steps you have to take to prepare your application to use       ¡ d ONLN dÿÿ         (È ZXTSMTE in any possible context. The following sections then look at the individual cases.    ¡ d ONLN dÿÿ         *Testing for TSMTE     ¡ d ONLN dÿÿ         *HBefore making calls for TSMTE, you have to check for its presence using      ¡ d ONLN dÿÿ         (ø¹Gestalt. The selector      ¡ d ONLN dÿÿ         ( Z7for TSMTE is gestaltTSMTEAttr, and you know that it is      ¡ d ONLN dÿÿ         (k$available if the gestaltTSMTEPresent       ¡ d ONLN dÿÿ         ( Zbit in the response is set.     ¡ d ONLN dÿÿ         *FThe following code initializes separate Boolean variables to indicate      ¡ d ONLN dÿÿ         ((¤the presence of the Text      ¡ d ONLN dÿÿ         (4 ZPServices Manager and TSMTE. Having separate variables is useful if you use your       ¡ d ONLN dÿÿ         (4ñown text       ¡ d ONLN dÿÿ         (@ Z^engine in addition to TextEdit and want to support inline input for that engine even if TSMTE       ¡ d ONLN dÿÿ         (@is       ¡ d ONLN dÿÿ         (L Znot present.  , 
 Courier    	 ¡ d ONLN dÿÿ         +&static void CheckForTextServices(void)  ¡ d ONLN dÿÿ         *
{  ¡ d ONLN dÿÿ         +
long gestaltResponse; ¡ d ONLN dÿÿ         *gHasTextServices = false;  ¡ d ONLN dÿÿ         )Û// unless proven otherwise ¡ d ONLN dÿÿ         (• {gHasTSMTE = false;  ¡ d ONLN dÿÿ         )Û// unless proven otherwise ¡ d ONLN dÿÿ         (© {if (TrapAvailable(_Gestalt))  *
{   Á XÁ    
 (Ö Z,TE 27 Ğ Inline Input for TextEdit with TSMTE  (Öÿ3 ) of 13 (ì ZM.TE.Inline Input for TextEdit  ÿr    ×# ÿ ÿÿÿÿ        #  ×            
    IR ,  Times    
 .      +6-Macintosh Technical Notes   / 4 /ù , 
 Courier    	 +0@if ((Gestalt(gestaltTSMgrVersion, &gestaltResponse) == noErr) &&  +
 (gestaltResponse >= 1))  ( X f{ +
gHasTextServices = true;  *
9if (Gestalt(gestaltTSMTEAttr, &gestaltResponse) == noErr)  ¡ d ONLN dÿÿ         +
7gHasTSMTE = BTst(gestaltResponse, gestaltTSMTEPresent); ¡ d ONLN dÿÿ         ( € f};  ¡ d ONLN dÿÿ         ( Š W};  ¡ d ONLN dÿÿ         ( ” H}       ¡ d ONLN dÿÿ         ( © 62Initializing and Closing the Text Services Manager         ¡ d ONLN dÿÿ         *ATo enable inline input, you have to initialize the Text Services       ¡ d ONLN dÿÿ         ( Á’Manager by calling       ¡ d ONLN dÿÿ         ( Í 6VInitTSMAwareApplication in your initialization sequence, and close it before quitting       ¡ d ONLN dÿÿ         ( ÍÉ
by calling       ¡ d ONLN dÿÿ         ( Ù 6>CloseTSMAwareApplication. But what if TSMTE is not available?       ¡ d ONLN dÿÿ         ( ÙtThen you have to make the ¡ d ONLN dÿÿ         ( å 6Vfloating input window available to the user for entering text in a 2-byte script into       ¡ d ONLN dÿÿ         ( åÆ
a TextEdit       ¡ d ONLN dÿÿ         ( ñ 6Ifield. How to do this depends on whether you use your own text engine in      ¡ d ONLN dÿÿ         ( ñ™addition to TextEdit  ¡ d ONLN dÿÿ         ( ı 6T(we assume that your own text engine supports inline input Ğ otherwise you probably       ¡ d ONLN dÿÿ         ( ıÚwould      ¡ d ONLN dÿÿ         (	 69not think about adding inline input support to TextEdit). ¡ d ONLN dÿÿ         *9If you only use TextEdit in your application, you simply       ¡ d ONLN dÿÿ         (!C$call InitTSMAwareApplication only if      ¡ d ONLN dÿÿ         (- 6FTSMTE is available. If you donÕt call InitTSMAwareApplication, system       ¡ d ONLN dÿÿ         (-µsoftware will     ¡ d ONLN dÿÿ         (9 6-automatically handle input in 2-byte scripts      ¡ d ONLN dÿÿ         )Ó0for your application in a floating input window.     ¡ d ONLN dÿÿ         (E 68The following code performs the initialization and also       ¡ d ONLN dÿÿ         (EB!shows how to move on without text      ¡ d ONLN dÿÿ         (Q 6*services if InitTSMAwareApplication fails:     	 ¡ d ONLN dÿÿ         +7if (!(gHasTSMTE && InitTSMAwareApplication() == noErr)) ¡ d ONLN dÿÿ         *
{  ¡ d ONLN dÿÿ         +
6// if this happens, just move on without text services  ¡ d ONLN dÿÿ         *
gHasTextServices = false;  ¡ d ONLN dÿÿ         *
gHasTSMTE = false; ¡ d ONLN dÿÿ         (š H};          ¡ d ONLN dÿÿ         (± 6,If you use your own text engine in addition       ¡ d ONLN dÿÿ         )Ø0to TextEdit and support inline input for it, you      ¡ d ONLN dÿÿ         (½ 6Ywant to use inline input for your engine even if TSMTE is not available. To do this, you      ¡ d ONLN dÿÿ         (½Øsimply       ¡ d ONLN dÿÿ         (É 69check gHasTextServices instead of gHasTSMTE in the first      ¡ d ONLN dÿÿ         (ÉS"line of the code above. Later, you       ¡ d ONLN dÿÿ         (Õ 6Salso have to make sure that you tell the Text Services Manager to use the floating      ¡ d ONLN dÿÿ         (Õµinput window  ¡ d ONLN dÿÿ         (á 6Lwhenever a TextEdit field is active Ğ the section ÒUsing TSMTE and TextEdit       ¡ d ONLN dÿÿ         (á³in Addition to       ¡ d ONLN dÿÿ         (í 6/Your Own Text EngineÓ discusses this in detail. ¡ d ONLN dÿÿ         *In       ¡ d ONLN dÿÿ         )Yeither case, you have to call CloseTSMAwareApplication before quitting an application for       ¡ d ONLN dÿÿ         ( 66which you successfully called InitTSMAwareApplication:     	 ¡ d ONLN dÿÿ         +if (gHasTextServices) ¡ d ONLN dÿÿ         +
"(void) CloseTSMAwareApplication();  ¡ d ONLN dÿÿ         (< HExitToShell();        ¡ d ONLN dÿÿ         (b 6Using TSMTE for Modal Dialogs      ¡ d ONLN dÿÿ         *IOnce you have initialized the Text Services Manager, TSMTE offers a very       ¡ d ONLN dÿÿ         (z›easy way to handle      ¡ d ONLN dÿÿ         († 63inline input for modal dialogs: you set the refCon      ¡ d ONLN dÿÿ         (†Nfield in the DLOG resource to      ¡ d ONLN dÿÿ         (’ 6RkTSMTEDialog or kTSMTEInterfaceType, TSMTE handles the rest. Or, if circumstances       ¡ d ONLN dÿÿ         (’àforce ¡ d ONLN dÿÿ         ( 6you to create a dialog      ¡ d ONLN dÿÿ         )l@programmatically, you can pass kTSMTEInterfaceType as the refCon      ¡ d ONLN dÿÿ         (ª 6+argument to NewDialog or NewCDialog (these      ¡ d ONLN dÿÿ         )á,routines do not accept kTSMTEDialog). Either  Á 4Áù  
      (Ö 64 ) of 13 )ş,TE 27 Ğ Inline Input for TextEdit with TSMTE +BM.TE.Inline Input for TextEdit  ÿ     ×# ÿ ÿÿÿÿ        #  ×            
    IR ,  Times    
 .      +Z-Developer Support Center  ( -ŞDecember 1993   / X /       ( E Zway, TSMTE will automatically       )9create a TSMDocument for you, activate and deactivate the      ( Q Z>TSMDocument, and enable inline input for the dialog. When you       ( Q¸call CloseDialog or      ( ] Z4DisposeDialog, TSMTE disposes of the TSMDocument it       ( ]m"created, activates the TSMDocument      ( i Z>that was active before opening the dialog (if there was one),       ( iand resets the Text Services       ¡ d ONLN dÿÿ         ( u Z\Manager flag that determines whether to use the floating input window to its previous state.    ¡ d ONLN dÿÿ         *Note:     ¡ d ONLN dÿÿ         )$<If you use this feature, you can still use the refCon field      ¡ d ONLN dÿÿ         ( ˆfor your own purposes      ¡ d ONLN dÿÿ         ( ™ ~=after creating the dialog Ğ TSMTE doesnÕt need it any longer. ¡ d ONLN dÿÿ         ( ± ZEThe difference between the two constants is that kTSMTEInterfaceType      ¡ d ONLN dÿÿ         ( ±¯tells TSMTE to use an     ¡ d ONLN dÿÿ         ( ½ ZAextended dialog record, TSMDialogRecord, while kTSMTEDialog uses      ¡ d ONLN dÿÿ         ( ½½the standard dialog     ¡ d ONLN dÿÿ         ( É ZYrecord. Using the extended dialog record lets you access the information that TSMTE uses      ¡ d ONLN dÿÿ         ( Éif       ¡ d ONLN dÿÿ         ( Õ ZWyou need it; without it, the information is stored in TSMTEÕs private data structures.      ¡ d ONLN dÿÿ         ( Õê
If you use  ¡ d ONLN dÿÿ         ( á ZkTSMTEInterfaceType       ¡ d ONLN dÿÿ         )qCbut donÕt provide storage for the dialog record, the Dialog Manager       ¡ d ONLN dÿÿ         ( í Z8routines will automatically allocate an extended record.  ¡ d ONLN dÿÿ         *=If you use kTSMTEInterfaceType and allocate your own storage       ¡ d ONLN dÿÿ         (or add your own fields to the     ¡ d ONLN dÿÿ         ( Z;dialog record, you have to take the additional 20 bytes of      ¡ d ONLN dÿÿ         (the extended dialog record into      ¡ d ONLN dÿÿ         ( Zaccount. If       ¡ d ONLN dÿÿ         )6Qyou add your own fields, itÕs a good idea to also allocate your own storage. This       ¡ d ONLN dÿÿ         () Z1way you can always include the fields for TSMTE,      ¡ d ONLN dÿÿ         )ô,otherwise the location of your fields in the      ¡ d ONLN dÿÿ         (5 Z4record depends on whether TSMTE is installed or not.  ¡ d ONLN dÿÿ         *(If you provide an event filter function      ¡ d ONLN dÿÿ         )´3for ModalDialog, TSMTE gives you the choice whether       ¡ d ONLN dÿÿ         (Y ZJyou want to handle Text Services Manager calls or whether TSMTE should do       ¡ d ONLN dÿÿ         (YÏit. To determine  ¡ d ONLN dÿÿ         (e ZZwhether the function handles the calls, TSMTE calls it with a null event. If the function       ¡ d ONLN dÿÿ         (ecalls     ¡ d ONLN dÿÿ         (q ZBTSMEvent, TSMTE assumes that the function makes all the necessary       ¡ d ONLN dÿÿ         (qÆcalls to the Text     ¡ d ONLN dÿÿ         (} Z9Services Manager. If it doesnÕt, or if there is no event      ¡ d ONLN dÿÿ         (}e$filter function, TSMTE makes all the       ¡ d ONLN dÿÿ         (‰ Znecessary calls itself.     ¡ d ONLN dÿÿ         *OWhile using inline input, ModalDialog doesnÕt return because it doesnÕt get to       ¡ d ONLN dÿÿ         (¡×see any ÒrealÓ       ¡ d ONLN dÿÿ         (­ Zevents. If you have a       ¡ d ONLN dÿÿ         )fIdialog that opens with a disabled action button and waits for the user to  ¡ d ONLN dÿÿ         (¹ ZAtype text into an editable text item before enabling the button,      ¡ d ONLN dÿÿ         (¹‡checking the editable text item      ¡ d ONLN dÿÿ         (Å ZNonly after ModalDialog returns does not have the desired effect Ğ if the user       ¡ d ONLN dÿÿ         (ÅÀuses inline input to       ¡ d ONLN dÿÿ         (Ñ Zenter text,       ¡ d ONLN dÿÿ         )2Vthe button doesnÕt get enabled. A solution for this is to use an event filter function ¡ d ONLN dÿÿ         (İ ZMthat checks the text in the editable text item and enables the button if the      ¡ d ONLN dÿÿ         (İ»text length is above       ¡ d ONLN dÿÿ         (é Z;zero. The event filter function is guaranteed to be called      ¡ d ONLN dÿÿ         (éb#with a null event whenever TSMEvent      ¡ d ONLN dÿÿ         (õ Zconsumes a keyDown event.     ¡ d ONLN dÿÿ         *'9Using TSMTE for Document Windows and for Modeless Dialogs           ¡ d ONLN dÿÿ         *;If you use TextEdit to edit text in document windows or if       ¡ d ONLN dÿÿ         (4{you use modeless dialogs, some       ¡ d ONLN dÿÿ         (@ ZQmore work is shifted over to you: now it becomes your responsibility to call the      ¡ d ONLN dÿÿ         (@Ôhigh-level Text      ¡ d ONLN dÿÿ         (L Z7Services Manager routines. YouÕll have to add calls to: , 
 Courier    	 ¡ d ONLN dÿÿ         +NewTSMDocument  ¡ d ONLN dÿÿ         *
DeleteTSMDocument  ¡ d ONLN dÿÿ         *
ActivateTSMDocument  ¡ d ONLN dÿÿ         *
DeactivateTSMDocument  ¡ d ONLN dÿÿ         *
TSMEvent ¡ d ONLN dÿÿ         *
TSMMenuSelect  ¡ d ONLN dÿÿ         *
SetTSMCursor ¡ d ONLN dÿÿ         *
FixTSMDocument  Á XÁ    
 (Ö Z,TE 27 Ğ Inline Input for TextEdit with TSMTE  (Öÿ5 ) of 13 (ì ZM.TE.Inline Input for TextEdit  ÿä    ×# ÿ ÿÿÿÿ        #  ×            
    IR ,  Times    
 .      +6-Macintosh Technical Notes   / 4 /ù   *$;Before making the Text Services Manager calls, you have to       ( QU"make sure that their preconditions  ( ] 6are met. You only       )\Dwant to create a TSM document for a TextEdit text record if TSMTE is      ( i 6.available. You only want to delete, activate,       )Ñ0or deactivate, or confirm (ÒfixÓ) a TSM document ¡ d ONLN dÿÿ         ( u 6if creating       ¡ d ONLN dÿÿ         )4Mit was successful. The remaining routines depend on the Text Services Manager       ¡ d ONLN dÿÿ         (  68being available, but not necessarily on TSMTE Ğ you may       ¡ d ONLN dÿÿ         ( K"be using your own text engine with      ¡ d ONLN dÿÿ         (  6&inline input in addition to TextEdit.       ¡ d ONLN dÿÿ         )À,The variables gHasTextServices and gHasTSMTE     ¡ d ONLN dÿÿ         ( ™ 6'introduced above can help you make the      ¡ d ONLN dÿÿ         )Õ+necessary decisions. For example, your menu       ¡ d ONLN dÿÿ         ( ¥ 6#handling code might look like this: , 
 Courier    	 ¡ d ONLN dÿÿ         +&menuResult = MenuSelect(event->where);  ¡ d ONLN dÿÿ         *
5if (!(gHasTextServices && TSMMenuSelect(menuResult)))  ¡ d ONLN dÿÿ         +
DoMenuCommand(menuResult);  ¡ d ONLN dÿÿ         ( Ú HHiliteMenu(0);          ¡ d ONLN dÿÿ         ( ñ 6The       ¡ d ONLN dÿÿ         )9usage of Text Services Manager routines is documented in     ¡ d ONLN dÿÿ         ( ñtInside Macintosh: Text     ¡ d ONLN dÿÿ         )p, so      ¡ d ONLN dÿÿ         ( ı 6IweÕll discuss only how TSMTE extends the Text Services Manager interface.   ¡ d ONLN dÿÿ         *Creating a TSM Document     ¡ d ONLN dÿÿ         *When creating a TSMDocument      ¡ d ONLN dÿÿ         )š?for a TextEdit text record, you have to use a special interface       ¡ d ONLN dÿÿ         (9 6type kTSMTEInterfaceType to       ¡ d ONLN dÿÿ         )“;indicate that TSMTE should handle Apple events for this TSM       ¡ d ONLN dÿÿ         (E 6	document.     ¡ d ONLN dÿÿ         *If       ¡ d ONLN dÿÿ         )Nyou pass kTSMTEInterfaceType to NewTSMDocument, the refCon argument takes on a      ¡ d ONLN dÿÿ         (i 6Xdifferent meaning. Instead of a value to be stored in the TSM document, you should pass       ¡ d ONLN dÿÿ         (iİin the      ¡ d ONLN dÿÿ         (u 6Raddress of a variable of type TSMTERecHandle. TSMTE allocates a data structure of       ¡ d ONLN dÿÿ         (uätype      ¡ d ONLN dÿÿ         ( 6TSMTERec and assigns a      ¡ d ONLN dÿÿ         )Chandle to it to your variable. This data structure contains several       ¡ d ONLN dÿÿ         ( 6fields that you can use to      ¡ d ONLN dÿÿ         )xDtailor TSMTEÕs behavior to the needs of your application. It is your      ¡ d ONLN dÿÿ         (™ 66applicationÕs responsibility to initialize the record.     	 ¡ d ONLN dÿÿ         +struct TSMTERec { ¡ d ONLN dÿÿ         +
TEHandle  ¡ d ONLN dÿÿ         )jtextH; ¡ d ONLN dÿÿ         (Ä WTSMTEPreUpdateUPP ¡ d ONLN dÿÿ         )jpreUpdateProc; ¡ d ONLN dÿÿ         (Î WTSMTEPostUpdateUPP  ¡ d ONLN dÿÿ         )jpostUpdateProc;  ¡ d ONLN dÿÿ         (Ø Wlong  ¡ d ONLN dÿÿ         )jupdateFlag;  ¡ d ONLN dÿÿ         (â Wlong  ¡ d ONLN dÿÿ         )jrefCon;  ¡ d ONLN dÿÿ         (ì H};      ¡ d ONLN dÿÿ         ( 6ZThe textH field has to be set to the text record handle that this TSM document relates to.  ¡ d ONLN dÿÿ         *In preUpdateProc and       ¡ d ONLN dÿÿ         )kCpostUpdateProc you can specify call-back routines that TSMTE should  ¡ d ONLN dÿÿ         (' 6Ycall before and after its own code when handling the Update Active Input Area event (one      ¡ d ONLN dÿÿ         ('îof      ¡ d ONLN dÿÿ         (3 6Pthe Apple events that is sent by the input method). The interfaces and possible       ¡ d ONLN dÿÿ         (3¶uses for both      ¡ d ONLN dÿÿ         (? 6Droutines are described below. If you donÕt have routines that TSMTE       ¡ d ONLN dÿÿ         (?should call, set the fields      ¡ d ONLN dÿÿ         (K 6to nil.     ¡ d ONLN dÿÿ         *HThe updateFlag field is intended for customization of TSMTEÕs behavior.      ¡ d ONLN dÿÿ         (c¨The idea is that      ¡ d ONLN dÿÿ         (o 6#TSMTE can define several constants      ¡ d ONLN dÿÿ         )¹3for variations in its behaviors, and you sum up the      ¡ d ONLN dÿÿ         ({ 66constants for the variations that you like and assign       ¡ d ONLN dÿÿ         )ı(them to the updateFlag field. Currently,      ¡ d ONLN dÿÿ         (‡ 69only one such constant, kTSMTEAutoScroll, is defined. It      ¡ d ONLN dÿÿ         (‡N"specifies that TSMTE automatically       ¡ d ONLN dÿÿ         (“ 6Wscrolls the selection range into view. If you set updateFlag to 0, automatic scrolling      ¡ d ONLN dÿÿ         (“Áis disabled,       ¡ d ONLN dÿÿ         (Ÿ 6Qand you have to scroll the text yourself, e.g., in one of the call-back routines.  Á 4Áù  
 *76  ) of 13 )ş,TE 27 Ğ Inline Input for TextEdit with TSMTE +BM.TE.Inline Input for TextEdit  ÿ
    ×# ÿ ÿÿÿÿ        #  ×            
    IR ,  Times    
 .      +Z-Developer Support Center  ( -ŞDecember 1993   / X /       ( E ZBThe refCon field lets you specify a value that TSMTE will pass on       ( E¢to the call-back routines.       ( Q Z/TSMTE doesnÕt make any other use of this field. *[Here is some sample code for creating a TSMDocument. It assumes that you have just created       ( ia ¡ d ONLN dÿÿ         ( u ZFTEHandle called docTEHandle, and that a Boolean variable good is used       ¡ d ONLN dÿÿ         ( u¿to indicate whether      ¡ d ONLN dÿÿ         (  ZBoperations are successful, and that you want to pass a pointer to       ¡ d ONLN dÿÿ         ( Šthe document window to your      ¡ d ONLN dÿÿ         (  Zcall-back routine.  , 
 Courier    	 ¡ d ONLN dÿÿ         +if (good && gHasTSMTE)  ¡ d ONLN dÿÿ         *
{  ¡ d ONLN dÿÿ         +
-supportedInterfaces[0] = kTSMTEInterfaceType; ¡ d ONLN dÿÿ         *
;if (NewTSMDocument(1, supportedInterfaces, &doc->docTSMDoc,  ¡ d ONLN dÿÿ         +-
)(long) &doc->docTSMTERecHandle) == noErr) ¡ d ONLN dÿÿ         ( Ö {{ ¡ d ONLN dÿÿ         +
4TSMTERecPtr tsmteRecPtr = *(doc->docTSMTERecHandle);  ¡ d ONLN dÿÿ         * tsmteRecPtr->textH = doc->docTE; ¡ d ONLN dÿÿ         *
0tsmteRecPtr->preUpdateProc = gTSMTEPreUpdateUPP; ¡ d ONLN dÿÿ         *
2tsmteRecPtr->postUpdateProc = gTSMTEPostUpdateUPP; ¡ d ONLN dÿÿ         *
+tsmteRecPtr->updateFlag = kTSMTEAutoScroll;  ¡ d ONLN dÿÿ         *
$tsmteRecPtr->refCon = (long) window; ¡ d ONLN dÿÿ         (& {} ¡ d ONLN dÿÿ         *
else ¡ d ONLN dÿÿ         +
good = false; ¡ d ONLN dÿÿ         (D l};      ¡ d ONLN dÿÿ         ([ ZUYou shouldnÕt dispose of the TSMTERecHandle Ğ DeleteTSMDocument will do this for you.   ¡ d ONLN dÿÿ         *$Using a Pre-Update Call-Back Routine    ¡ d ONLN dÿÿ         *EPre-update call-back routines for TSMTE have the following interface:     	 ¡ d ONLN dÿÿ         +>pascal void MyTSMTEPreUpdateProc(TEHandle textH, long refCon);      ¡ d ONLN dÿÿ         (¹ Z;If you provide a pre-update routine for a TSM document, it      ¡ d ONLN dÿÿ         (¹t!is called before TSMTEÕs code for      ¡ d ONLN dÿÿ         (Å ZGhandling the Update Active Input Area events relating to this document.     ¡ d ONLN dÿÿ         *=The values for the textH and refCon arguments are taken from       ¡ d ONLN dÿÿ         (İthe TSMTERecHandle of the      ¡ d ONLN dÿÿ         (é ZTSM document. ¡ d ONLN dÿÿ         *4One common use of the pre-update routine is to save      ¡ d ONLN dÿÿ         )û(information that will be needed for Undo ¡ d ONLN dÿÿ         ( Z
and Redo.       ¡ d ONLN dÿÿ         )6RWithout inline input, an application typically treats an uninterrupted sequence of     ¡ d ONLN dÿÿ         ( Z!keyDown events (other than arrow      ¡ d ONLN dÿÿ         )¬8or function keys) as one action, and saves the currently     ¡ d ONLN dÿÿ         (% Zselected text and related       ¡ d ONLN dÿÿ         )vDinformation when receiving the first event in this sequence. In this      ¡ d ONLN dÿÿ         (1 Z;regard, you should treat a call to your pre-update routine      ¡ d ONLN dÿÿ         (1g&as just another form of typing, and if       ¡ d ONLN dÿÿ         (= ZGitÕs the first one in a typing sequence, save the information for Undo.     ¡ d ONLN dÿÿ         *8Another use is to work around a bug in TSMTE 1.0, which      ¡ d ONLN dÿÿ         (U‚doesnÕt always synchronize the      ¡ d ONLN dÿÿ         (a Zfont to be used       ¡ d ONLN dÿÿ         )MJwith the current keyboard script. The following routine checks whether the ¡ d ONLN dÿÿ         (m ZGcurrent font can display the incoming characters, and if not, sets the      ¡ d ONLN dÿÿ         (m´font to the keyboard      ¡ d ONLN dÿÿ         (y Z>scriptÕs application font. A better solution would be to scan       ¡ d ONLN dÿÿ         (y~the text backwards for the most     ¡ d ONLN dÿÿ         (… Z	recently      ¡ d ONLN dÿÿ         ))Rused font of the keyboard script. This solution will be used by future versions of      ¡ d ONLN dÿÿ         (‘ Z/TSMTE, so make sure to check the TSMTE version      ¡ d ONLN dÿÿ         )ø%and use the workaround only for TSMTE       ¡ d ONLN dÿÿ         ( Z1.0, as       ¡ d ONLN dÿÿ         )$Rshown below. The synchronization is only necessary when a new active input area is      ¡ d ONLN dÿÿ         (© Z\created, so you may want to use the post-update routine to track whether there is an active       ¡ d ONLN dÿÿ         (©input  Á XÁ  
      (Ö Z,TE 27 Ğ Inline Input for TextEdit with TSMTE  (Öÿ7 ) of 13 (ì ZM.TE.Inline Input for TextEdit  ÿ¸    ×# ÿ ÿÿÿÿ        #  ×            
    IR ,  Times    
 .      +6-Macintosh Technical Notes   / 4 /ù   *Parea and only execute the font synchronization code when the pre-update routine      ( E³is called while      ( Q 6thereÕs no active input area. , 
 Courier    	 +Dstatic pascal void MyTSMTEPreUpdateProc(TEHandle textH, long refCon)  ¡ d ONLN dÿÿ         *
{  ¡ d ONLN dÿÿ         +
long response;  ¡ d ONLN dÿÿ         *
ScriptCode keyboardScript; ¡ d ONLN dÿÿ         *
short mode;  ¡ d ONLN dÿÿ         *
TextStyle theStyle;  ¡ d ONLN dÿÿ         *9if ((Gestalt(gestaltTSMTEVersion, &response) == noErr) &&  ¡ d ONLN dÿÿ         +
 (response == gestaltTSMTE1)) ¡ d ONLN dÿÿ         ( Â W{ ¡ d ONLN dÿÿ         +
7keyboardScript = GetScriptManagerVariable(smKeyScript); ¡ d ONLN dÿÿ         *
mode = doFont; ¡ d ONLN dÿÿ         *
3if (!(TEContinuousStyle(&mode, &theStyle, textH) &&  ¡ d ONLN dÿÿ         +
1FontToScript(theStyle.tsFont) == keyboardScript)) ¡ d ONLN dÿÿ         ( ô f{ ¡ d ONLN dÿÿ         +
EtheStyle.tsFont = GetScriptVariable(keyboardScript, smScriptAppFond); ¡ d ONLN dÿÿ         *
,TESetStyle(doFont, &theStyle, false, textH); ¡ d ONLN dÿÿ         ( f};  ¡ d ONLN dÿÿ         ( W};  ¡ d ONLN dÿÿ         (& H}       ¡ d ONLN dÿÿ         (= 6Note:    ¡ d ONLN dÿÿ         )$,Depending on which interface files you use,      ¡ d ONLN dÿÿ         )Ó you may have to use the old name      ¡ d ONLN dÿÿ         (I ZGetEnvirons       ¡ d ONLN dÿÿ         )??instead of the new GetScriptManagerVariable, because thereÕs no  ¡ d ONLN dÿÿ         (U Zcorrect declaration       ¡ d ONLN dÿÿ         )[9for the new name. The universal interfaces have a correct       ¡ d ONLN dÿÿ         (a Zdeclaration.  ¡ d ONLN dÿÿ         (y 6If      ¡ d ONLN dÿÿ         )[your application occasionally changes the origin of the TextEdit recordÕs grafPort, you can      ¡ d ONLN dÿÿ         (… 6Talso use the pre-update routine to reset the origin so that characters get drawn in       ¡ d ONLN dÿÿ         (…Î	the right      ¡ d ONLN dÿÿ         (‘ 6	location.   ¡ d ONLN dÿÿ         *%Using a Post-Update Call-Back Routine     ¡ d ONLN dÿÿ         *FPost-update call-back routines for TSMTE have the following interface:    	 ¡ d ONLN dÿÿ         +>pascal void MyTSMTEPostUpdateProc(TEHandle textH, long fixLen,  ¡ d ONLN dÿÿ         +-
'long inputAreaStart, long inputAreaEnd, ¡ d ONLN dÿÿ         *
)long pinStart, long pinEnd, long refCon);      ¡ d ONLN dÿÿ         ( 6)If you provide a post-update routine for      ¡ d ONLN dÿÿ         )¾3a TSM document, it is called after TSMTEÕs code for      ¡ d ONLN dÿÿ         ( 6handling Update       ¡ d ONLN dÿÿ         )UGActive Input Area events relating to this document. If you have set the      ¡ d ONLN dÿÿ         ( 6IupdateFlag field in the TSMTERec record to kTSMTEAutoScroll, TSMTE calls      ¡ d ONLN dÿÿ         (»the call-back      ¡ d ONLN dÿÿ         (' 6>routine first, and then scrolls the selection range into view.      ¡ d ONLN dÿÿ         *=The values for the textH and refCon arguments are taken from       ¡ d ONLN dÿÿ         (?ithe TSMTERecHandle of the     ¡ d ONLN dÿÿ         (K 66TSM document. InputAreaStart and inputAreaEnd are the       ¡ d ONLN dÿÿ         (KO#offsets of the start and end of the     ¡ d ONLN dÿÿ         (W 6Hactive input area relative to the entire text handle; they are both set       ¡ d ONLN dÿÿ         (Wzto -1 if there is no active      ¡ d ONLN dÿÿ         (c 6Sinput area. The remaining parameters are a subset of the parameters for the Update      ¡ d ONLN dÿÿ         (c½Active Input       ¡ d ONLN dÿÿ         (o 6Area event. The       ¡ d ONLN dÿÿ         )NMfixLen parameter is the length of the confirmed text. PinStart and pinEnd are       ¡ d ONLN dÿÿ         ({ 6Jthe offsets of the start and end of the text range that should be in view.  ¡ d ONLN dÿÿ         *+Common uses of the post-update routine are:  ¡ d ONLN dÿÿ         *¥      ¡ d ONLN dÿÿ         )Kadjusting scroll bars or input field widths to the width and height of the       ¡ d ONLN dÿÿ         (Ÿ¨text, which may      ¡ d ONLN dÿÿ         (« Hhave changed during editing,   Á 4Áù  
 (Ö 68 ) of 13 )ş,TE 27 Ğ Inline Input for TextEdit with TSMTE +BM.TE.Inline Input for TextEdit  ÿØ    ×# ÿ ÿÿÿÿ        #  ×            
    IR ,  Times    
 .      +Z-Developer Support Center  ( -ŞDecember 1993   / X /   ( E Z¥ )+setting a ÒmodifiedÓ flag for the document,  ( Q Z¥ )Bsaving information about the text being entered for Undo and Redo, ( ] Z¥ )6keeping track of whether thereÕs an active input area.   ¡ d ONLN dÿÿ         (  ZCalling FixTSMDocument         ¡ d ONLN dÿÿ         *SThe FixTSMDocument routine should be called whenever the user switches from typing       ¡ d ONLN dÿÿ         ( ™	to a       ¡ d ONLN dÿÿ         ( ¥ Z0different kind of activity that operates on the       ¡ d ONLN dÿÿ         )Ó2text, e.g., initiating an editing command from the     ¡ d ONLN dÿÿ         ( ± Zmenu      ¡ d ONLN dÿÿ         )Sor selecting text. It should not be called for actions that would not be considered       ¡ d ONLN dÿÿ         ( ½ Z/interrupting a typing sequence, e.g., resizing      ¡ d ONLN dÿÿ         )×/or scrolling the window. There are some actions       ¡ d ONLN dÿÿ         ( É Z_in between for which we donÕt have clear guidelines yet; in these cases use your best judgment. ¡ d ONLN dÿÿ         * TSMTE will in some cases detect      ¡ d ONLN dÿÿ         ) 9that FixTSMDocument needs to be called and do it for you,  ¡ d ONLN dÿÿ         ( í Z*e.g., when the user clicks into a part of       ¡ d ONLN dÿÿ         )Å2the document outside the input area. In most cases     ¡ d ONLN dÿÿ         ( ù Z%however it is your responsibility to      ¡ d ONLN dÿÿ         )®3call FixTSMDocument when appropriate: when the user       ¡ d ONLN dÿÿ         ( ZPselects an editing command from the menu, closes a document, saves or prints it.      ¡ d ONLN dÿÿ         *'<Using TSMTE and TextEdit in Addition to Your Own Text Engine          ¡ d ONLN dÿÿ         *GIf you use your own text engine in addition to TextEdit, you will have       ¡ d ONLN dÿÿ         (Dµto provide your own     ¡ d ONLN dÿÿ         (P ZApple event handlers for      ¡ d ONLN dÿÿ         ){Athe Text Services Apple events to implement inline input for your       ¡ d ONLN dÿÿ         (\ Z)engine. However, you can still use TSMTE      ¡ d ONLN dÿÿ         )Ñ1to provide inline input wherever you use TextEdit       ¡ d ONLN dÿÿ         (h Zin your application.  ¡ d ONLN dÿÿ         *.Your Apple event handlers donÕt need to worry      ¡ d ONLN dÿÿ         )â/about TextEdit at all. TSMTE installs its event      ¡ d ONLN dÿÿ         (Œ ZWhandlers in the system heap, so you can install your handlers in the application heap.      ¡ d ONLN dÿÿ         (Œ
The      ¡ d ONLN dÿÿ         (˜ Z:supported interface type that you specify when you create       ¡ d ONLN dÿÿ         (˜l#a TSM document is used to arbitrate ¡ d ONLN dÿÿ         (¤ ZTbetween the handlers: for TSM documents that were created with kTSMTEInterfaceType,       ¡ d ONLN dÿÿ         (¤the      ¡ d ONLN dÿÿ         (° ZYTSMTE handlers are called, for those that  were created with kTextService, your handlers. ¡ d ONLN dÿÿ         *RThe only thing you have to worry about is what to do if the Text Services Manager      ¡ d ONLN dÿÿ         (Èãis available,      ¡ d ONLN dÿÿ         (Ô Zbut not TSMTE, so that you can      ¡ d ONLN dÿÿ         )›>provide inline input for your engine, but not for TextEdit. In ¡ d ONLN dÿÿ         (à ZZthis case you want to make sure that inline input is used whenever your engine is active,       ¡ d ONLN dÿÿ         (àbut      ¡ d ONLN dÿÿ         (ì Z that a floating input window is       ¡ d ONLN dÿÿ         )“?made available whenever a TextEdit field is active (without the       ¡ d ONLN dÿÿ         (ø Z6floating input window users would not be able to type       ¡ d ONLN dÿÿ         (ø\(anything meaningful in a 2-byte script).  ¡ d ONLN dÿÿ         ( Z3You can do this by calling UseInputWindow whenever      ¡ d ONLN dÿÿ         (i%you activate or deactivate a TextEdit      ¡ d ONLN dÿÿ         ( Z,record Ğ here is sample code for activation:  , 
 Courier    	 ¡ d ONLN dÿÿ         +if (doc->docTSMDoc != nil)  ¡ d ONLN dÿÿ         +
0CheckError(ActivateTSMDocument(doc->docTSMDoc));  ¡ d ONLN dÿÿ         (; lelse  ¡ d ONLN dÿÿ         +
&CheckError(UseInputWindow(nil, true));        ¡ d ONLN dÿÿ         (k ZMore Inline Input Advice           ¡ d ONLN dÿÿ         *This section       ¡ d ONLN dÿÿ         )@Kcontains some information that is not specific to TSMTE, but applies to all       ¡ d ONLN dÿÿ         ( Zapplications that use the       ¡ d ONLN dÿÿ         )s@Text Services Manager in any form. It shows workarounds for some     ¡ d ONLN dÿÿ         (› ZOunexpected features (we wonÕt use entomological terminology hereÉ) in the Text      ¡ d ONLN dÿÿ         (›ôServices       ¡ d ONLN dÿÿ         (§ ZManager       ¡ d ONLN dÿÿ         ),Tand first-generation input methods written for it. Some of those unexpected features      (³ ZGare expected to be or have already been discontinued in newer versions.  Á XÁ  
 *#,TE 27 Ğ Inline Input for TextEdit with TSMTE (Öÿ9 ) of 13 (ì ZM.TE.Inline Input for TextEdit  ÿÎ    ×# ÿ ÿÿÿÿ        #  ×            
    IR ,  Times    
 .      +6-Macintosh Technical Notes   / 4 /ù     *$'Incorrect Declaration in TextServices.p         *XThe Text Services interface file TextServices.p that is currently distributed on E.T.O.      ( iÖ12 and      ¡ d ONLN dÿÿ         ( u 6+the November 1993 Developer CD contains an      ¡ d ONLN dÿÿ         )æ)incorrect declaration for NewTSMDocument.       ¡ d ONLN dÿÿ         (  6The declaration should read:  , 
 Courier    	 ¡ d ONLN dÿÿ         +0Function NewTSMDocument(numOfInterface: Integer;  ¡ d ONLN dÿÿ         +
JVAR supportedInterfaceTypes: InterfaceTypeList; VAR idocID: TSMDocumentID;  ¡ d ONLN dÿÿ         *
refCon: Longint): OSErr; ¡ d ONLN dÿÿ         ( ¶ WINLINE $303C, $0000, $AA54;         ¡ d ONLN dÿÿ         ( Í 6Without the keyword       ¡ d ONLN dÿÿ         )pBÒvarÓ in front of ÒsupportedInterfaceTypesÓ, your application will      ¡ d ONLN dÿÿ         ( Ù 6encounter a bus       ¡ d ONLN dÿÿ         )MHerror in NewTSMDocument. So, go in and add the keyword ÒvarÓ if itÕs not      ¡ d ONLN dÿÿ         ( å 6there.  ¡ d ONLN dÿÿ         *@The declaration for NewTSMDocument in TextServices.h is correct.   ¡ d ONLN dÿÿ         *&DeleteTSMDocument Uses Disposed Handle    ¡ d ONLN dÿÿ         *If a TSMDocument is deleted      ¡ d ONLN dÿÿ         )>without being deactivated first, the routine DeleteTSMDocument ¡ d ONLN dÿÿ         (9 6may reuse a handle that       ¡ d ONLN dÿÿ         )vDit has already disposed of. It dereferences this handle and writes a      ¡ d ONLN dÿÿ         (E 6Nsingle byte. This may eventually cause your application to crash mysteriously.      ¡ d ONLN dÿÿ         *Workaround: make sure to       ¡ d ONLN dÿÿ         )‰8deactivate each TSM document using DeactivateTSMDocument     ¡ d ONLN dÿÿ         (i 6Tbefore calling DeleteTSMDocument to delete it. If TSMTE calls DeleteTSMDocument for       ¡ d ONLN dÿÿ         (ióa      ¡ d ONLN dÿÿ         (u 6CTSM document it created for a modal dialog it does the right thing.   ¡ d ONLN dÿÿ         *2ActivateTSMDocument Must Be Called From Foreground        ¡ d ONLN dÿÿ         *ActivateTSMDocument does not       ¡ d ONLN dÿÿ         )¥3work properly if called from the background. When a       ¡ d ONLN dÿÿ         (± 6window      ¡ d ONLN dÿÿ         )*Nthat owns a TSM document is coming to the foreground from the background, your     ¡ d ONLN dÿÿ         (½ 6Kapplication is supposed to call ActivateTSMDocument with the TSMDocumentID      ¡ d ONLN dÿÿ         (½Òfor that      ¡ d ONLN dÿÿ         (É 6&window.  However, if your application       ¡ d ONLN dÿÿ         )Ã5makes this call while still in the background, inline       ¡ d ONLN dÿÿ         (Õ 6Binput may not become re-enabled in that window. Applications that       ¡ d ONLN dÿÿ         (Õufollow the usual scheme of       ¡ d ONLN dÿÿ         (á 6Qactivating windows after receiving an activate event shouldnÕt have any problems.   ¡ d ONLN dÿÿ         *SetTSMCursor and Cursor Regions         ¡ d ONLN dÿÿ         */Applications that use TSM are supposed to call       ¡ d ONLN dÿÿ         )è)SetTSMCursor generously in order to allow  ¡ d ONLN dÿÿ         ( 6TSM components to set       ¡ d ONLN dÿÿ         ){>the cursor when they need to do so. Unfortunately, there is no      ¡ d ONLN dÿÿ         () 6	protocol      ¡ d ONLN dÿÿ         )*Sfor finding out in which region the input method would want to set the cursor. This       ¡ d ONLN dÿÿ         (5 6)presents a problem for many applications      ¡ d ONLN dÿÿ         )Å5that try to be cooperative by passing a cursor region      ¡ d ONLN dÿÿ         (A 6=to WaitNextEvent. Without information from the input method,      ¡ d ONLN dÿÿ         (Atan application using inline      ¡ d ONLN dÿÿ         (M 63input cannot calculate a meaningful cursor region,      ¡ d ONLN dÿÿ         )î)and thus has to be run whenever the mouse       ¡ d ONLN dÿÿ         (Y 6moved.  ¡ d ONLN dÿÿ         **The only thing you can currently do is to      ¡ d ONLN dÿÿ         )Ã4define a 1-pixel cursor region under the mouse point     ¡ d ONLN dÿÿ         (} 6and pass this region to       ¡ d ONLN dÿÿ         )w=WaitNextEvent. This setup will cause mouse-moved events to be      ¡ d ONLN dÿÿ         (‰ 6Qgenerated whenever the mouse is moved, but will let the application sleep if the      ¡ d ONLN dÿÿ         (‰¼mouse stays      ¡ d ONLN dÿÿ         (• 6put.   Á 4Áù  
 *A10 )
 of 13 )ù,TE 27 Ğ Inline Input for TextEdit with TSMTE +BM.TE.Inline Input for TextEdit  ÿ.    ×# ÿ ÿÿÿÿ        #  ×            
    IR ,  Times    
 .      +Z-Developer Support Center  ( -ŞDecember 1993   / X /     ( E ZStrange Delete Key Behavior    *If you       ) Tuse Kotoeri, AppleÕs Japanese input method, you may notice that deletion of Japanese ( i Z*characters in the active input area using       )Â3the delete character does not work properly in your       ¡ d ONLN dÿÿ         ( u Z7application. This is more likely to happen with styled      ¡ d ONLN dÿÿ         )ı'text or on non-Japanese system software       ¡ d ONLN dÿÿ         (  Z(e.g., with       ¡ d ONLN dÿÿ         )6Rthe Japanese Language Kit installed). Kotoeri thinks that it is using a Roman font ¡ d ONLN dÿÿ         (  Zand only deletes one byte for       ¡ d ONLN dÿÿ         )‘>each delete key pressed. This results in the need to press the      ¡ d ONLN dÿÿ         ( ™ Z`delete key twice to delete a single Japanese character as well as other strange inline behavior.      ¡ d ONLN dÿÿ         *<Workaround: Add some code around your call to TSMEvent that      ¡ d ONLN dÿÿ         ( ±˜sets the font in the current       ¡ d ONLN dÿÿ         ( ½ ZDgrafPort to one of the keyboard script, and resets it afterwards if       ¡ d ONLN dÿÿ         ( ½Œnecessary. KotoeriÕs behavior ¡ d ONLN dÿÿ         ( É Z?depends on the font in the current grafPort that it encounters      ¡ d ONLN dÿÿ         ( Éƒduring your call to TSMEvent.      ¡ d ONLN dÿÿ         ( Õ ZKHere is a routine that you can call instead of TSMEvent to accomplish this: , 
 Courier    	 ¡ d ONLN dÿÿ         +/static Boolean IntlTSMEvent(EventRecord *event) ¡ d ONLN dÿÿ         *
{  ¡ d ONLN dÿÿ         +
short oldFont;  ¡ d ONLN dÿÿ         *
ScriptCode keyboardScript; ¡ d ONLN dÿÿ         *if (qd.thePort != nil) ¡ d ONLN dÿÿ         *
{  ¡ d ONLN dÿÿ         +
oldFont = qd.thePort->txFont; ¡ d ONLN dÿÿ         *
7keyboardScript = GetScriptManagerVariable(smKeyScript);  ¡ d ONLN dÿÿ         *
,if (FontToScript(oldFont) != keyboardScript) ¡ d ONLN dÿÿ         +
=TextFont(GetScriptVariable(keyboardScript, smScriptAppFond)); ¡ d ONLN dÿÿ         (Z {};  ¡ d ONLN dÿÿ         *
return TSMEvent(event);  ¡ d ONLN dÿÿ         (n l}     ¡ d ONLN dÿÿ         (… ZYou should also make sure       ¡ d ONLN dÿÿ         )ƒEthat the current grafPort at this point is the one in which the input       ¡ d ONLN dÿÿ         (‘ Zwill be displayed.      ¡ d ONLN dÿÿ         *3Pascal Summary   ¡ d ONLN dÿÿ         *	Constants        	 ¡ d ONLN dÿÿ         +const ¡ d ONLN dÿÿ         +{ signature, interface types }  ¡ d ONLN dÿÿ         *kTSMTESignature = 'tmTE';  ¡ d ONLN dÿÿ         *
&kTSMTEInterfaceType = kTSMTESignature; ¡ d ONLN dÿÿ         *
kTSMTEDialog = 'tmDI'; ¡ d ONLN dÿÿ         *{ Gestalt }  ¡ d ONLN dÿÿ         *#gestaltTSMTEAttr = kTSMTESignature;  ¡ d ONLN dÿÿ         *
gestaltTSMTEPresent = 0; ¡ d ONLN dÿÿ         *
gestaltTSMTEVersion = 'tmTV';  ¡ d ONLN dÿÿ         *
gestaltTSMTE1 = $0100; ¡ d ONLN dÿÿ         *{ update flag for TSMTERec } ¡ d ONLN dÿÿ         *kTSMTEAutoScroll = 1;   Á XÁ    
 (Ö Z,TE 27 Ğ Inline Input for TextEdit with TSMTE  (Öú11  )
 of 13 (ì ZM.TE.Inline Input for TextEdit  ÿ    ×# ÿ ÿÿÿÿ        #  ×            
    IR ,  Times    
 .      +6-Macintosh Technical Notes   / 4 /ù     *
Data Types , 
 Courier       	 +type  ¡ d ONLN dÿÿ         +TSMTERec = record ¡ d ONLN dÿÿ         +
textH:  ¡ d ONLN dÿÿ         )[	TEHandle;  ¡ d ONLN dÿÿ         ( „ fpreUpdateProc:  ¡ d ONLN dÿÿ         )[ProcPtr; ¡ d ONLN dÿÿ         (  fpostUpdateProc: ¡ d ONLN dÿÿ         )[ProcPtr; ¡ d ONLN dÿÿ         ( ˜ fupdateFlag: ¡ d ONLN dÿÿ         )[Longint; ¡ d ONLN dÿÿ         ( ¢ frefCon: ¡ d ONLN dÿÿ         )[Longint; ¡ d ONLN dÿÿ         ( ¬ fend;  ¡ d ONLN dÿÿ         ( À WTSMTERecPtr = ^TSMTERec;  ¡ d ONLN dÿÿ         *
TSMTERecHandle = ^TSMTERecPtr; ¡ d ONLN dÿÿ         *TSMDialogRecord = record ¡ d ONLN dÿÿ         +
fDialog:  ¡ d ONLN dÿÿ         )[DialogRecord;  ¡ d ONLN dÿÿ         ( ò ffDocID: ¡ d ONLN dÿÿ         )[TSMDocumentID; ¡ d ONLN dÿÿ         ( ü ffTSMTERecH: ¡ d ONLN dÿÿ         )[TSMTERecHandle;  ¡ d ONLN dÿÿ         ( ffTSMTERsvd: ¡ d ONLN dÿÿ         )[array [0..2] of Longint; ¡ d ONLN dÿÿ         ( fend;  ¡ d ONLN dÿÿ         ($ W!TSMDialogPeek = ^TSMDialogRecord;       ¡ d ONLN dÿÿ         (; 6Application-Defined Routines        	 ¡ d ONLN dÿÿ         +Aprocedure MyTSMTEPreUpdateProc(textH: TEHandle; refCon: Longint); ¡ d ONLN dÿÿ         *
Aprocedure MyTSMTEPostUpdateProc(textH: TEHandle; fixLen: Longint;  ¡ d ONLN dÿÿ         +
&inputAreaStart, inputAreaEnd: Longint;  ¡ d ONLN dÿÿ         *
,pinStart, pinEnd: Longint; refCon: Longint);       ¡ d ONLN dÿÿ         (¢ 6	C Summary   ¡ d ONLN dÿÿ         *	Constants        	 ¡ d ONLN dÿÿ         +// signature, interface types ¡ d ONLN dÿÿ         *enum  {  ¡ d ONLN dÿÿ         +
kTSMTESignature ¡ d ONLN dÿÿ         )j	= 'tmTE',  ¡ d ONLN dÿÿ         (ù WkTSMTEInterfaceType ¡ d ONLN dÿÿ         )j= kTSMTESignature, ¡ d ONLN dÿÿ         ( WkTSMTEDialog  ¡ d ONLN dÿÿ         )j= 'tmDI' ¡ d ONLN dÿÿ         ( H};  ¡ d ONLN dÿÿ         *
// Gestalt ¡ d ONLN dÿÿ         *enum  {  ¡ d ONLN dÿÿ         +
gestaltTSMTEAttr  ¡ d ONLN dÿÿ         )j= kTSMTESignature, ¡ d ONLN dÿÿ         (I WgestaltTSMTEPresent ¡ d ONLN dÿÿ         )j= 0, ¡ d ONLN dÿÿ         (S WgestaltTSMTEVersion ¡ d ONLN dÿÿ         )j	= 'tmTV',  ¡ d ONLN dÿÿ         (] WgestaltTSMTE1 ¡ d ONLN dÿÿ         )j= 0x100  ¡ d ONLN dÿÿ         (g H};  ¡ d ONLN dÿÿ         *// update flag for TSMTERec  ¡ d ONLN dÿÿ         *enum  {  ¡ d ONLN dÿÿ         +
kTSMTEAutoScroll  ¡ d ONLN dÿÿ         )j= 1  ¡ d ONLN dÿÿ         (¥ H};   Á 4Áù    
 (Ö 612  )
 of 13 )ù,TE 27 Ğ Inline Input for TextEdit with TSMTE +BM.TE.Inline Input for TextEdit  ÿ	Ø    ×# ÿ ÿÿÿÿ        #  ×            
    IR ,  Times    
 .      +Z-Developer Support Center  ( -ŞDecember 1993   / X /     ( E Z
Data Types  , 
 Courier       	 +I// the following proc ptr declarations come with the usual complements of *
7// universal proc ptr declarations and related routines  ¡ d ONLN dÿÿ         *Jtypedef pascal void (*TSMTEPreUpdateProcPtr)(TEHandle textH, long refCon); ¡ d ONLN dÿÿ         *Jtypedef pascal void (*TSMTEPostUpdateProcPtr)(TEHandle textH, long fixLen, ¡ d ONLN dÿÿ         +
'long inputAreaStart, long inputAreaEnd, ¡ d ONLN dÿÿ         *
)long pinStart, long pinEnd, long refCon);  ¡ d ONLN dÿÿ         ( ¶ lstruct TSMTERec { ¡ d ONLN dÿÿ         +
TEHandle  ¡ d ONLN dÿÿ         )jtextH; ¡ d ONLN dÿÿ         ( Ê {TSMTEPreUpdateUPP ¡ d ONLN dÿÿ         )jpreUpdateProc; ¡ d ONLN dÿÿ         ( Ô {TSMTEPostUpdateUPP  ¡ d ONLN dÿÿ         )jpostUpdateProc;  ¡ d ONLN dÿÿ         ( Ş {long  ¡ d ONLN dÿÿ         )jupdateFlag;  ¡ d ONLN dÿÿ         ( è {long  ¡ d ONLN dÿÿ         )jrefCon;  ¡ d ONLN dÿÿ         ( ò l};  ¡ d ONLN dÿÿ         *Atypedef struct TSMTERec TSMTERec, *TSMTERecPtr, **TSMTERecHandle;  ¡ d ONLN dÿÿ         *struct TSMDialogRecord { ¡ d ONLN dÿÿ         +
DialogRecord  ¡ d ONLN dÿÿ         )jfDialog; ¡ d ONLN dÿÿ         (. {TSMDocumentID ¡ d ONLN dÿÿ         )jfDocID;  ¡ d ONLN dÿÿ         (8 {TSMTERecHandle  ¡ d ONLN dÿÿ         )jfTSMTERecH;  ¡ d ONLN dÿÿ         (B {long  ¡ d ONLN dÿÿ         )jfTSMTERsvd[3]; ¡ d ONLN dÿÿ         (L l};  ¡ d ONLN dÿÿ         *?typedef struct TSMDialogRecord TSMDialogRecord, *TSMDialogPeek;        ¡ d ONLN dÿÿ         (w ZApplication-Defined Routines        	 ¡ d ONLN dÿÿ         +>pascal void MyTSMTEPreUpdateProc(TEHandle textH, long refCon);  ¡ d ONLN dÿÿ         *
>pascal void MyTSMTEPostUpdateProc(TEHandle textH, long fixLen, ¡ d ONLN dÿÿ         +
'long inputAreaStart, long inputAreaEnd, ¡ d ONLN dÿÿ         *
)long pinStart, long pinEnd, long refCon);        ¡ d ONLN dÿÿ         (Ï ZFurther Reference:   Ò XÒ    ¡ d ONLN dÿÿ         +¥   ¡ d ONLN dÿÿ         )Inside Macintosh: Text,     ¡ d ONLN dÿÿ         )p Text Services Manager ¡ d ONLN dÿÿ         (è l¥ ¡ d ONLN dÿÿ         ) Sample Code: ÒInlineInputSampleÓ  Á XÁ  
 (Ö Z,TE 27 Ğ Inline Input for TextEdit with TSMTE  (Öú13  )
 of 13 (ì ZM.TE.Inline Input for TextEdit  ÿ