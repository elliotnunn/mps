;
;    File:       MacTypes.a
;
;    Contains:   Basic Macintosh data types.
;
;    Version:    Technology: Mac OS 9
;                Release:    Universal Interfaces 3.4
;
;    Copyright:  © 1985-2001 by Apple Computer, Inc., all rights reserved.
;
;    Bugs?:      For bug reports, consult the following page on
;                the World Wide Web:
;
;                    http://developer.apple.com/bugreporter/
;
;
	IF &TYPE('__MACTYPES__') = 'UNDEFINED' THEN
__MACTYPES__ SET 1

	IF &TYPE('__CONDITIONALMACROS__') = 'UNDEFINED' THEN
	include 'ConditionalMacros.a'
	ENDIF


; ********************************************************************************
;
;    Base integer types for all target OS's and CPU's
;    
;        UInt8            8-bit unsigned integer 
;        SInt8            8-bit signed integer
;        UInt16          16-bit unsigned integer 
;        SInt16          16-bit signed integer           
;        UInt32          32-bit unsigned integer 
;        SInt32          32-bit signed integer   
;        UInt64          64-bit unsigned integer 
;        SInt64          64-bit signed integer   
;
;********************************************************************************

; typedef unsigned char 				UInt8

; typedef signed char 					SInt8

; typedef unsigned short 				UInt16

; typedef signed short 					SInt16

; typedef unsigned long 				UInt32

; typedef signed long 					SInt32

	IF TARGET_RT_BIG_ENDIAN THEN
wide					RECORD 0
hi						 ds.l	1				; offset: $0 (0)
lo						 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
UnsignedWide			RECORD 0
hi						 ds.l	1				; offset: $0 (0)
lo						 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
	ELSE
wide					RECORD 0
lo						 ds.l	1				; offset: $0 (0)
hi						 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
UnsignedWide			RECORD 0
lo						 ds.l	1				; offset: $0 (0)
hi						 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
	ENDIF	; TARGET_RT_BIG_ENDIAN
SInt64					RECORD 0
f						 ds		wide
sizeof					 EQU *					; size:   $8 (8)
						ENDR


UInt64					RECORD 0
f						 ds		UnsignedWide
sizeof					 EQU *					; size:   $8 (8)
						ENDR



; ********************************************************************************
;
;    Base fixed point types 
;    
;        Fixed           16-bit signed integer plus 16-bit fraction
;        UnsignedFixed   16-bit unsigned integer plus 16-bit fraction
;        Fract           2-bit signed integer plus 30-bit fraction
;        ShortFixed      8-bit signed integer plus 8-bit fraction
;        
;********************************************************************************

; typedef long 							Fixed

; typedef Fixed *						FixedPtr

; typedef long 							Fract

; typedef Fract *						FractPtr

; typedef unsigned long 				UnsignedFixed

; typedef UnsignedFixed *				UnsignedFixedPtr

; typedef short 						ShortFixed

; typedef ShortFixed *					ShortFixedPtr



; ********************************************************************************
;
;    Base floating point types 
;    
;        Float32         32 bit IEEE float:  1 sign bit, 8 exponent bits, 23 fraction bits
;        Float64         64 bit IEEE float:  1 sign bit, 11 exponent bits, 52 fraction bits  
;        Float80         80 bit MacOS float: 1 sign bit, 15 exponent bits, 1 integer bit, 63 fraction bits
;        Float96         96 bit 68881 float: 1 sign bit, 15 exponent bits, 16 pad bits, 1 integer bit, 63 fraction bits
;        
;    Note: These are fixed size floating point types, useful when writing a floating
;          point value to disk.  If your compiler does not support a particular size 
;          float, a struct is used instead.
;          Use of of the NCEG types (e.g. double_t) or an ANSI C type (e.g. double) if
;          you want a floating point representation that is natural for any given
;          compiler, but might be a different size on different compilers.
;
;********************************************************************************

Float32					RECORD 0
bits					 ds.l	1				; offset: $0 (0)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
Float64					RECORD 0
bits					 ds.l	2				; offset: $0 (0)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
Float80					RECORD 0
exp						 ds.w	1				; offset: $0 (0)
man						 ds.w	4				; offset: $2 (2)
sizeof					 EQU *					; size:   $A (10)
						ENDR
Float96					RECORD 0
exp						 ds.w	1				; offset: $0 (0)
filler					 ds.w	1				; offset: $2 (2)
man						 ds.w	4				; offset: $4 (4)
sizeof					 EQU *					; size:   $C (12)
						ENDR
Float32Point			RECORD 0
x						 ds		Float32			; offset: $0 (0)
y						 ds		Float32			; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR

; ********************************************************************************
;
;    MacOS Memory Manager types
;    
;        Ptr             Pointer to a non-relocatable block
;        Handle          Pointer to a master pointer to a relocatable block
;        Size            The number of bytes in a block (signed for historical reasons)
;        
;********************************************************************************

; typedef SInt8 *						Ptr

; typedef Ptr *							Handle

; typedef long 							Size


; ********************************************************************************
;
;    Higher level basic types
;    
;        OSErr                   16-bit result error code
;        OSStatus                32-bit result error code
;        LogicalAddress          Address in the clients virtual address space
;        ConstLogicalAddress     Address in the clients virtual address space that will only be read
;        PhysicalAddress         Real address as used on the hardware bus
;        BytePtr                 Pointer to an array of bytes
;        ByteCount               The size of an array of bytes
;        ByteOffset              An offset into an array of bytes
;        ItemCount               32-bit iteration count
;        OptionBits              Standard 32-bit set of bit flags
;        PBVersion               ?
;        Duration                32-bit millisecond timer for drivers
;        AbsoluteTime            64-bit clock
;        ScriptCode              A particular set of written characters (e.g. Roman vs Cyrillic) and their encoding
;        LangCode                A particular language (e.g. English), as represented using a particular ScriptCode
;        RegionCode              Designates a language as used in a particular region (e.g. British vs American
;                                English) together with other region-dependent characteristics (e.g. date format)
;        FourCharCode            A 32-bit value made by packing four 1 byte characters together
;        OSType                  A FourCharCode used in the OS and file system (e.g. creator)
;        ResType                 A FourCharCode used to tag resources (e.g. 'DLOG')
;        
;********************************************************************************

; typedef SInt16 						OSErr

; typedef SInt32 						OSStatus

; typedef void *						LogicalAddress

; typedef const void *					ConstLogicalAddress

; typedef void *						PhysicalAddress

; typedef UInt8 *						BytePtr

; typedef UInt32 						ByteCount

; typedef UInt32 						ByteOffset

; typedef SInt32 						Duration

AbsoluteTime			RECORD 0
f						 ds		UnsignedWide
sizeof					 EQU *					; size:   $8 (8)
						ENDR


; typedef UInt32 						OptionBits

; typedef UInt32 						ItemCount

; typedef UInt32 						PBVersion

; typedef SInt16 						ScriptCode

; typedef SInt16 						LangCode

; typedef SInt16 						RegionCode

; typedef unsigned long 				FourCharCode

; typedef FourCharCode 					OSType

; typedef FourCharCode 					ResType

; typedef OSType *						OSTypePtr

; typedef ResType *						ResTypePtr


; ********************************************************************************
;
;    Boolean types and values
;    
;        Boolean         A one byte value, holds "false" (0) or "true" (1)
;        false           The Boolean value of zero (0)
;        true            The Boolean value of one (1)
;        
;********************************************************************************


false							EQU		0
true							EQU		1
; typedef unsigned char 				Boolean

; ********************************************************************************
;
;    Function Pointer Types
;    
;        ProcPtr                 Generic pointer to a function
;        Register68kProcPtr      Pointer to a 68K function that expects parameters in registers
;        UniversalProcPtr        Pointer to classic 68K code or a RoutineDescriptor
;        
;        ProcHandle              Pointer to a ProcPtr
;        UniversalProcHandle     Pointer to a UniversalProcPtr
;        
;********************************************************************************

;  UniversalProcPtr is ^RoutineDescriptor on a PowerPC machine 
; typedef ProcPtr 						UniversalProcPtr

; typedef ProcPtr *						ProcHandle

; typedef UniversalProcPtr *			UniversalProcHandle



; ********************************************************************************
;
;    Common Constants
;    
;        noErr                   OSErr: function performed properly - no error
;        kNilOptions             OptionBits: all flags false
;        kInvalidID              KernelID: NULL is for pointers as kInvalidID is for ID's
;        kVariableLengthArray    array bounds: variable length array
;
;    Note: kVariableLengthArray is used in array bounds to specify a variable length array.
;          It is ususally used in variable length structs when the last field is an array
;          of any size.  Before ANSI C, we used zero as the bounds of variable length 
;          array, but zero length array are illegal in ANSI C.  Example usage:
;    
;        struct FooList 
;        {
;            short   listLength;
;            Foo     elements[kVariableLengthArray];
;        };
;        
;********************************************************************************


noErr							EQU		0

kNilOptions						EQU		0

kInvalidID						EQU		0

kVariableLengthArray			EQU		1

kUnknownType					EQU		$3F3F3F3F			; "????" QuickTime 3.0: default unknown ResType or OSType 


; ********************************************************************************
;
;    String Types and Unicode Types
;    
;        UnicodeScalarValue,     A complete Unicode character in UTF-32 format, with
;        UTF32Char               values from 0 through 0x10FFFF (excluding the surrogate
;                                range 0xD800-0xDFFF and certain disallowed values).
;
;        UniChar,                A 16-bit Unicode code value in the default UTF-16 format.
;        UTF16Char               UnicodeScalarValues 0-0xFFFF are expressed in UTF-16
;                                format using a single UTF16Char with the same value.
;                                UnicodeScalarValues 0x10000-0x10FFFF are expressed in
;                                UTF-16 format using a pair of UTF16Chars - one in the
;                                high surrogate range (0xD800-0xDBFF) followed by one in
;                                the low surrogate range (0xDC00-0xDFFF). All of the
;                                characters defined in Unicode versions through 3.0 are
;                                in the range 0-0xFFFF and can be expressed using a single
;                                UTF16Char, thus the term "Unicode character" generally
;                                refers to a UniChar = UTF16Char.
;
;        UTF8Char                An 8-bit code value in UTF-8 format. UnicodeScalarValues
;                                0-0x7F are expressed in UTF-8 format using one UTF8Char
;                                with the same value. UnicodeScalarValues above 0x7F are
;                                expressed in UTF-8 format using 2-4 UTF8Chars, all with
;                                values in the range 0x80-0xF4 (UnicodeScalarValues
;                                0x100-0xFFFF use two or three UTF8Chars,
;                                UnicodeScalarValues 0x10000-0x10FFFF use four UTF8Chars).
;
;        UniCharCount            A count of UTF-16 code values in an array or buffer.
;
;        StrNNN                  Pascal string holding up to NNN bytes
;        StringPtr               Pointer to a pascal string
;        StringHandle            Pointer to a StringPtr
;        ConstStringPtr          Pointer to a read-only pascal string
;        ConstStrNNNParam        For function parameters only - means string is const
;        
;        CStringPtr              Pointer to a C string           (in C:  char*)
;        ConstCStringPtr         Pointer to a read-only C string (in C:  const char*)
;        
;    Note: The length of a pascal string is stored as the first byte.
;          A pascal string does not have a termination byte.
;          A pascal string can hold at most 255 bytes of data.
;          The first character in a pascal string is offset one byte from the start of the string. 
;          
;          A C string is terminated with a byte of value zero.  
;          A C string has no length limitation.
;          The first character in a C string is the zeroth byte of the string. 
;          
;        
;********************************************************************************

; typedef UInt32 						UnicodeScalarValue

; typedef UInt32 						UTF32Char

; typedef UInt16 						UniChar

; typedef UInt16 						UTF16Char

; typedef UInt8 						UTF8Char

; typedef UniChar *						UniCharPtr

; typedef UInt32 						UniCharCount

; typedef UniCharCount *				UniCharCountPtr

Str255					RECORD 0
elements				 ds.b	256
sizeof					 EQU *					; size:   $100 (256)
						ENDR


Str63					RECORD 0
elements				 ds.b	64
sizeof					 EQU *					; size:   $40 (64)
						ENDR


Str32					RECORD 0
elements				 ds.b	33
						 ORG 34
sizeof					 EQU *					; size:   $22 (34)
						ENDR


Str31					RECORD 0
elements				 ds.b	32
sizeof					 EQU *					; size:   $20 (32)
						ENDR


Str27					RECORD 0
elements				 ds.b	28
sizeof					 EQU *					; size:   $1C (28)
						ENDR


Str15					RECORD 0
elements				 ds.b	16
sizeof					 EQU *					; size:   $10 (16)
						ENDR


; 
;    The type Str32 is used in many AppleTalk based data structures.
;    It holds up to 32 one byte chars.  The problem is that with the
;    length byte it is 33 bytes long.  This can cause weird alignment
;    problems in structures.  To fix this the type "Str32Field" has
;    been created.  It should only be used to hold 32 chars, but
;    it is 34 bytes long so that there are no alignment problems.
;

Str32Field				RECORD 0
elements				 ds.b	34
sizeof					 EQU *					; size:   $22 (34)
						ENDR


; 
;    QuickTime 3.0:
;    The type StrFileName is used to make MacOS structs work 
;    cross-platform.  For example FSSpec or SFReply previously
;    contained a Str63 field.  They now contain a StrFileName
;    field which is the same when targeting the MacOS but is
;    a 256 char buffer for Win32 and unix, allowing them to
;    contain long file names.
;

	IF TARGET_OS_MAC THEN
StrFileName				RECORD 0
f						 ds		Str63
sizeof					 EQU *					; size:   $40 (64)
						ENDR


	ELSE
StrFileName				RECORD 0
f						 ds		Str255
sizeof					 EQU *					; size:   $100 (256)
						ENDR


	ENDIF	; TARGET_OS_MAC
; ********************************************************************************
;
;    Quickdraw Types
;    
;        Point               2D Quickdraw coordinate, range: -32K to +32K
;        Rect                Rectangular Quickdraw area
;        Style               Quickdraw font rendering styles
;        StyleParameter      Style when used as a parameter (historical 68K convention)
;        StyleField          Style when used as a field (historical 68K convention)
;        CharParameter       Char when used as a parameter (historical 68K convention)
;        
;    Note:   The original Macintosh toolbox in 68K Pascal defined Style as a SET.  
;            Both Style and CHAR occupy 8-bits in packed records or 16-bits when 
;            used as fields in non-packed records or as parameters. 
;        
;********************************************************************************

Point					RECORD 0
v						 ds.w	1				; offset: $0 (0)
h						 ds.w	1				; offset: $2 (2)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef struct Point *				PointPtr

Rect					RECORD 0
top						 ds.w	1				; offset: $0 (0)
left					 ds.w	1				; offset: $2 (2)
bottom					 ds.w	1				; offset: $4 (4)
right					 ds.w	1				; offset: $6 (6)
						 ORG 0
topLeft					 ds		Point			; offset: $0 (0)
botRight				 ds		Point			; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
; typedef union Rect *					RectPtr

FixedPoint				RECORD 0
x						 ds.l	1				; offset: $0 (0)
y						 ds.l	1				; offset: $4 (4)
sizeof					 EQU *					; size:   $8 (8)
						ENDR
FixedRect				RECORD 0
left					 ds.l	1				; offset: $0 (0)
top						 ds.l	1				; offset: $4 (4)
right					 ds.l	1				; offset: $8 (8)
bottom					 ds.l	1				; offset: $C (12)
sizeof					 EQU *					; size:   $10 (16)
						ENDR
; typedef short 						CharParameter


normal							EQU		0
bold							EQU		1
italic							EQU		2
underline						EQU		4
outline							EQU		8
shadow							EQU		$10
condense						EQU		$20
extend							EQU		$40
; typedef unsigned char 				Style

; typedef short 						StyleParameter

; typedef short 						StyleField



; ********************************************************************************
;
;    QuickTime TimeBase types (previously in Movies.h)
;    
;        TimeValue           Count of units
;        TimeScale           Units per second
;        CompTimeValue       64-bit count of units (always a struct) 
;        TimeValue64         64-bit count of units (long long or struct) 
;        TimeBase            An opaque reference to a time base
;        TimeRecord          Package of TimeBase, duration, and scale
;        
;********************************************************************************

; typedef long 							TimeValue

; typedef long 							TimeScale

CompTimeValue			RECORD 0
f						 ds		wide
sizeof					 EQU *					; size:   $8 (8)
						ENDR


TimeValue64				RECORD 0
f						 ds		SInt64
sizeof					 EQU *					; size:   $8 (8)
						ENDR




TimeRecord				RECORD 0
value					 ds		CompTimeValue	; offset: $0 (0)		;  units (duration or absolute) 
scale					 ds.l	1				; offset: $8 (8)		;  units per second 
base					 ds.l	1				; offset: $C (12)		;  refernce to the time base 
sizeof					 EQU *					; size:   $10 (16)
						ENDR



; ********************************************************************************
;
;    MacOS versioning structures
;    
;        VersRec                 Contents of a 'vers' resource
;        VersRecPtr              Pointer to a VersRecPtr
;        VersRecHndl             Resource Handle containing a VersRec
;        NumVersion              Packed BCD version representation (e.g. "4.2.1a3" is 0x04214003)
;        UniversalProcPtr        Pointer to classic 68K code or a RoutineDescriptor
;        
;        ProcHandle              Pointer to a ProcPtr
;        UniversalProcHandle     Pointer to a UniversalProcPtr
;        
;********************************************************************************

	IF TARGET_RT_BIG_ENDIAN THEN
NumVersion				RECORD 0
;  Numeric version part of 'vers' resource 
majorRev				 ds.b	1				; offset: $0 (0)		; 1st part of version number in BCD
minorAndBugRev			 ds.b	1				; offset: $1 (1)		; 2nd & 3rd part of version number share a byte
stage					 ds.b	1				; offset: $2 (2)		; stage code: dev, alpha, beta, final
nonRelRev				 ds.b	1				; offset: $3 (3)		; revision level of non-released version
sizeof					 EQU *					; size:   $4 (4)
						ENDR
	ELSE
NumVersion				RECORD 0
;  Numeric version part of 'vers' resource accessable in little endian format 
nonRelRev				 ds.b	1				; offset: $0 (0)		; revision level of non-released version
stage					 ds.b	1				; offset: $1 (1)		; stage code: dev, alpha, beta, final
minorAndBugRev			 ds.b	1				; offset: $2 (2)		; 2nd & 3rd part of version number share a byte
majorRev				 ds.b	1				; offset: $3 (3)		; 1st part of version number in BCD
sizeof					 EQU *					; size:   $4 (4)
						ENDR
	ENDIF	; TARGET_RT_BIG_ENDIAN

															; Version Release Stage Codes 
developStage					EQU		$20
alphaStage						EQU		$40
betaStage						EQU		$60
finalStage						EQU		$80
NumVersionVariant		RECORD 0
;  NumVersionVariant is a wrapper so NumVersion can be accessed as a 32-bit value 
parts					 ds		NumVersion		; offset: $0 (0)
						 ORG 0
whole					 ds.l	1				; offset: $0 (0)
sizeof					 EQU *					; size:   $4 (4)
						ENDR
; typedef union NumVersionVariant *		NumVersionVariantPtr

; typedef NumVersionVariantPtr *		NumVersionVariantHandle

VersRec					RECORD 0
;  'vers' resource format 
numericVersion			 ds		NumVersion		; offset: $0 (0)		; encoded version number
countryCode				 ds.w	1				; offset: $4 (4)		; country code from intl utilities
shortVersion			 ds		Str255			; offset: $6 (6)		; version number string - worst case
reserved				 ds		Str255			; offset: $106 (262)	; longMessage string packed after shortVersion
sizeof					 EQU *					; size:   $206 (518)
						ENDR
; typedef struct VersRec *				VersRecPtr

; typedef VersRecPtr *					VersRecHndl

; *********************************************************************************
;
;    Old names for types
;        
;********************************************************************************

; typedef UInt8 						Byte

; typedef SInt8 						SignedByte

; typedef struct wide *					WidePtr

; typedef struct UnsignedWide *			UnsignedWidePtr

extended80				RECORD 0
f						 ds		Float80
sizeof					 EQU *					; size:   $A (10)
						ENDR


extended96				RECORD 0
f						 ds		Float96
sizeof					 EQU *					; size:   $C (12)
						ENDR


; typedef SInt8 						VHSelect

; *********************************************************************************
;
;    Debugger functions
;    
;********************************************************************************


; *  Debugger()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void Debugger(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_Debugger:	OPWORD	$A9FF
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Debugger
	ENDIF


; *  DebugStr()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void DebugStr(ConstStr255Param debuggerMsg)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		_DebugStr:	OPWORD	$ABFF
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DebugStr
	ENDIF

	IF TARGET_OS_MAC THEN
	IF TARGET_CPU_PPC THEN
;  Only for Mac OS native drivers 
	IF CALL_NOT_IN_CARBON THEN

; *  SysDebug()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in DriverServicesLib 1.0 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void SysDebug(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SysDebug
	ENDIF


; *  SysDebugStr()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in DriverServicesLib 1.0 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; extern void SysDebugStr(ConstStr255Param str)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SysDebugStr
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	ENDIF	; TARGET_CPU_PPC
;  SADE break points 

; *  SysBreak()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void SysBreak(void )
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SysBreak
			move.w              #$FE16,D0
			dc.w            	$A9C9
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SysBreak
	ENDIF


; *  SysBreakStr()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void SysBreakStr(ConstStr255Param debuggerMsg)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SysBreakStr
			move.w              #$FE15,D0
			dc.w            	$A9C9
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SysBreakStr
	ENDIF


; *  SysBreakFunc()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        in CarbonLib 1.0 and later
; *    Mac OS X:         in version 10.0 or later
; 

;
; pascal void SysBreakFunc(ConstStr255Param debuggerMsg)
;
	IF TARGET_OS_MAC ** TARGET_CPU_68K ** ¬ TARGET_RT_MAC_CFM THEN
		Macro
		_SysBreakFunc
			move.w              #$FE14,D0
			dc.w            	$A9C9
		EndM
	ELSEIF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION SysBreakFunc
	ENDIF

	IF CALL_NOT_IN_CARBON THEN

; *  Debugger68k()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void Debugger68k(void )
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION Debugger68k
	ENDIF


; *  DebugStr68k()
; *  
; *  Availability:
; *    Non-Carbon CFM:   in InterfaceLib 7.1 and later
; *    CarbonLib:        not available
; *    Mac OS X:         not available
; 

;
; pascal void DebugStr68k(ConstStr255Param debuggerMsg)
;
	IF TARGET_OS_MAC ** TARGET_RT_MAC_CFM THEN
		IMPORT_CFM_FUNCTION DebugStr68k
	ENDIF

	ENDIF	; CALL_NOT_IN_CARBON
	ENDIF	; TARGET_OS_MAC

	ENDIF ; __MACTYPES__ 

