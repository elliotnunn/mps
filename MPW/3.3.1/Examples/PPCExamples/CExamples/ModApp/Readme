Introduction
------------
ModApp is a "modular" application written by Richard Clark of Apple's
Developer University. ModApp serves as a demonstration and test bed
for loading external code modules into an application. ModApp can load
PowerPC modules from the data fork of a file or from a resource,
and can load 68K code from a resource.

(Note: The terms "tool" and "module" are used interchangably throughout
this document.)

Some of the things that ModApp demonstrates are:
	• Using CFM for conventional shared libraries (GWorldTools)
	• Using CFM for custom additions (PowerPC modules)
	• Calling 68K code directly
	• Using MixedMode for Toolbox callbacks (Apple events support)

The code is portable between the PowerPC compilers, THINK C, and Code
Warrior from Metrowerks. ModApp can be built in a 68K version, a PowerPC
or as a "fat binary" which incorporates both. The few instances where
the PowerPC code deviates from the 68K code (declaring the "qd" global,
creating a UniversalProcPtr for callbacks) are surrounded by "#ifdef powerc".
(which is declared for all PowerPC compilers for the Macintosh.)


Building ModApp
---------------
ModApp has an MPW make file to build it and all tools. The default 
makefile builds "fat" versions of the application and all tools.
	• Building "all" will build a "fat" version of the app and all tools
	• Building "ModApp" creates a "fat" version of the app, while 
	  building "ModApp.68K" makes a 68K-only version and building
	  "ModApp.PowerPC" creates a PowerPC-only version.
	• Building ":Modules"Clock" builds only the clock module, or 
	  you can substitute another module name.
	  
NOTE: The makefile requires 3 subfolders in the ModApp folder:
Modules, PowerPC, and 68K. Running the "MakeFolders" script will
create these for you if they don't exist already.

If you construct your own makefile, or move this to another development
system, note that the "Koch" and "Clock" modules depend on the "GWorldTools"
library.

The default build has symbols turned *off* and optimization set for *size*. 
Editing the "SYM" variable at the start of the makefile turns symbolic
debugging on and off, editing "OPT" controls the optimization level (for PowerPC.)
These options also can be set from the command line
	make ModApp -d SYM=on -d OPT=off
builds a debugging version. (Note that SYM=on implies OPT=off)

Theory of Operation
-------------------
ModApp is a fairly standard Macintosh application, though it doesn't print or scroll.
The interesting part has to do with how modules are loaded and executed. The really
crucial information is contained in ToolLoader.c, ToolAPI.h, and the tool files
themselves.

Since ModApp has to support both 68K and PowerPC modules, almost all calls to a module
are done through Universal Procedure Pointers. When the module's initialization routine
is called, it creates a UPP for each entry point and places these in the "ToolInfoBlock"
data structure. (See the ToolStartup routine in Button.c for an example of this.) ModApp
then uses these UniversalProcedurePointers to call the module.

(Currently, modules do not call back to the main application, though if they did I would
probably implement these callbacks using a similar table mechanism.)

The only exception to the "modules are called via Universal Procedure Pointers" rule 
is the module's "ToolStartup" routine. This routine may be called directly, or through
a UniversalProcPtr -- see "InitializeTool" in ToolLoader.c for details.

The structure of a tool
-----------------------
A 68K module is implemented as a single 'TOOL' (0) resource, and has all of the
limitations of 68K stand-alone code.

A PowerPC module may be implemented as either a PEF container in the data fork of the
module's file, or as a 'TOOL' (1) resource containing a PEF container. (NOTE: In ModApp,
the PowerPC resource should not have a routine descriptor at the front, as it will be
loaded and called as a native code fragment -- see LoadViaCFM in ToolLoader.c) PowerPC
modules also have to contain a 'cfrg' resource to designate them as native; the type
should be set to "kIsDropIn" and the location set to either kOnDiskFlat (for the data
fork) or kInMem (for a resource).

"Fat" modules contain both kinds of code in the appropriate places. Don't forget the
'cfrg' resource!

The sample modules
------------------
ModApp ships with several sample modules, ranging from simple frameworks to a fancy
fractal drawing demonstration:
	• Simple — a basic do-nothing module, that just draws a black rectangle in the window.
	• Button - displays a single push button and beeps when the button is pressed. This
	  module demonstrates how a module should handle getting its own resources.
	• Clock - A basic analog clock with a sweep-second hand. This demonstrates how a 
	  module can install and remove menus and get idle time. Clock uses the "GWorldTools"
	  library for off-screen drawing. (supplied)
	• Koch - Draws the von Koch "snowflake" fractal over and over, rotating and colorizing
	  the result. This is a nice demonstration of Quickdraw's performance.
	and finally...
	• PowerResource - A really trivial module, but one that shows how to build and load
	  PowerPC code resources (without going through Mixed Mode.)

For more information...
-----------------------
If you have any questions or comments about ModApp, please send them to the
AppleLink address RDCLARK, or on the internet to "rdclark@apple.com"
