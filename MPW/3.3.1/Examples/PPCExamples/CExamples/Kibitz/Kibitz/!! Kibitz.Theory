The area that needs most explaining in Kibitz is the AppleEvents stuff.  This
turned out to be trickier than I had thought it would be.  It wasn't creating
or sending the AppleEvents that was difficult.  This turned out to be rather
easy.  The problem was the hand-shaking necessary to keep the game(s) in sync
on each machine.

The first version sent the entire game when a two-player session was
established.  Moves were then sent from that point.  The first version also
had undo/redo capability so that a user could back up the game a bit, and then
after reviewing a previous position, redo forward to the current position.  I
sent these undo/redo events to the other player, as well as regular moves.

The reason that these undo/redo events were sent is so that the two games
would always be in sync.  The problem was that, just as one player was moving
a piece, the other player could undo a move.  These messages would cross each
other in transmission, and when recieved, would be processed.  This could (and
did) cause the two board positions to not be in sync.  Obviously, some form of
hand-shaking was necessary.

What I chose to do was to always transmit the entire game.  In sending a new
game, I could then use a scrollbar to view previous positions.  By sending
the entire game, I gained random access to any position in the game.

Of course, once I added the slider (custom scrollbar), then there was the
problem that both players could be scrolling at the same time.  Each machine
would be sending lots of AppleEvents, and neither one would be paying
attention to them.  They would just queue up, and when the scrollbars were
finally released, the board position events would be processed.  This
processing of lots of queued events would cause the board to jump from one
position to another, and then finally settle down when all the events were
received and handled.

This simultaneous scrolling also caused the board positions to be out of sync.
That's when I decided that I needed a creator of the game.  (The creator
machine is the machine that initiated the game.)  The creator echos changes
back to the other player.  This would guarantee that if the two board
positions got out of sync, that they would get synced up again.  There is no
way to prevent them from getting out of sync, since the users can be scrolling
at each end at the same time.

This echoing by the creator solved a lot of problems.  For example:  There is
a resign button that you can push if you wish to throw in the towel.  It is
possible that both users could do this at the same time.  A resign message is
sent to the other machine.  Both players get the message that the opponent
resigned.  So, who won?  The creator machine echos what it received, which
may change the state of the other machine.  This echoing of resignation
messages guarantees that only one player can resign.

This should help you understand why I am sending the kind of events that I
am, and some of the decisions that I made as to how to do stuff.  The rest
of the application is rather straightforward application stuff, although
there is a lot of code.  I think (hope) that there are enough comments in
the code to explain everything.


Eric Soldan
