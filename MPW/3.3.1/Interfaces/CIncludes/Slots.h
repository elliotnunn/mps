/*
	File:		Slots.h

	Copyright:	Â© 1984-1993 by Apple Computer, Inc., all rights reserved.

	WARNING
	This file was auto generated by the interfacer tool. Modifications
	must be made to the master file.

*/

#ifndef __SLOTS__
#define __SLOTS__

#ifndef __TYPES__
#include <Types.h>
/*	#include <ConditionalMacros.h>								*/
/*	#include <MixedMode.h>										*/
/*		#include <Traps.h>										*/
#endif

#ifndef __EVENTS__
#include <Events.h>
/*	#include <Quickdraw.h>										*/
/*		#include <QuickdrawText.h>								*/
/*			#include <IntlResources.h>							*/
/*	#include <OSUtils.h>										*/
#endif

#ifndef __OSUTILS__
#endif

#ifndef __FILES__
#include <Files.h>
/*	#include <SegLoad.h>										*/
#endif

enum  {
	fCardIsChanged				= 1,							/*Card is Changed field in StatusFlags field of sInfoArray*/
	fCkForSame					= 0,							/*For SearchSRT. Flag to check for SAME sResource in the table. */
	fCkForNext					= 1,							/*For SearchSRT. Flag to check for NEXT sResource in the table. */
	fWarmStart					= 2,							/*If this bit is set then warm start else cold start.*/
	stateNil					= 0,							/*State*/
	stateSDMInit				= 1,							/*:Slot declaration manager Init*/
	statePRAMInit				= 2,							/*:sPRAM record init*/
	statePInit					= 3,							/*:Primary init*/
	stateSInit					= 4,							/*:Secondary init*/
/* flags for spParamData */
	fall						= 0,							/* bit 0: set=search enabled/disabled sRsrc's */
	foneslot					= 1,							/*    1: set=search sRsrc's in given slot only */
	fnext						= 2								/*    2: set=search for next sRsrc */
};


/*
	SlotIntServiceProcs cannot be written in or called from a high-level 
	language without the help of mixed mode or assembly glue because they 
	use the following parameter-passing convention:

	typedef pascal short (*SlotIntServiceProcPtr)(long sqParameter);

		In:
			=> 	sqParameter				A1.L
		Out:
			<=	interrupt handled flag	D0.W
*/

enum  {
	uppSlotIntServiceProcInfo	= kRegisterBased|RESULT_SIZE(kTwoByteCode)|REGISTER_RESULT_LOCATION(kRegisterD0)|REGISTER_ROUTINE_PARAMETER(1,kRegisterA1,kFourByteCode)
};

#if USESROUTINEDESCRIPTORS
typedef pascal short (*SlotIntServiceProcPtr)(long sqParameter);

typedef UniversalProcPtr SlotIntServiceUPP;

#define CallSlotIntServiceProc(userRoutine, sqParameter)  \
	CallUniversalProc((UniversalProcPtr)(userRoutine), uppSlotIntServiceProcInfo, (sqParameter))

#define NewSlotIntServiceProc(userRoutine)  \
	(SlotIntServiceUPP) NewRoutineDescriptor((ProcPtr)(userRoutine), uppSlotIntServiceProcInfo, GetCurrentISA())

#else
typedef ProcPtr SlotIntServiceUPP;

#define NewSlotIntServiceProc(userRoutine)  \
	(SlotIntServiceUPP)(userRoutine)

#endif

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct SlotIntQElement {
	Ptr							sqLink;							/*ptr to next element*/
	short						sqType;							/*queue type ID for validity*/
	short						sqPrio;							/*priority*/
	SlotIntServiceUPP			sqAddr;							/*interrupt service routine*/
	long						sqParm;							/*optional A1 parameter*/
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct SlotIntQElement SlotIntQElement;

typedef SlotIntQElement *SQElemPtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct SpBlock {
	long						spResult;						/*FUNCTION Result*/
	Ptr							spsPointer;						/*structure pointer*/
	long						spSize;							/*size of structure*/
	long						spOffsetData;					/*offset/data field used by sOffsetData*/
	Ptr							spIOFileName;					/*ptr to IOFile name for sDisDrvrName*/
	Ptr							spsExecPBlk;					/*pointer to sExec parameter block.*/
	long						spParamData;					/*misc parameter data (formerly spStackPtr).*/
	long						spMisc;							/*misc field for SDM.*/
	long						spReserved;						/*reserved for future expansion*/
	short						spIOReserved;					/*Reserved field of Slot Resource Table*/
	short						spRefNum;						/*RefNum*/
	short						spCategory;						/*sType: Category*/
	short						spCType;						/*Type*/
	short						spDrvrSW;						/*DrvrSW*/
	short						spDrvrHW;						/*DrvrHW*/
	char						spTBMask;						/*type bit mask bits 0..3 mask words 0..3*/
	char						spSlot;							/*slot number*/
	char						spID;							/*structure ID*/
	char						spExtDev;						/*ID of the external device*/
	char						spHwDev;						/*Id of the hardware device.*/
	char						spByteLanes;					/*bytelanes from card ROM format block*/
	char						spFlags;						/*standard flags*/
	char						spKey;							/*Internal use only*/
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct SpBlock SpBlock;

typedef SpBlock *SpBlockPtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct SInfoRecord {
	Ptr							siDirPtr;						/*Pointer to directory*/
	short						siInitStatusA;					/*initialization E*/
	short						siInitStatusV;					/*status returned by vendor init code*/
	char						siState;						/*initialization state*/
	char						siCPUByteLanes;					/*0=[d0..d7] 1=[d8..d15]*/
	char						siTopOfROM;						/*Top of ROM= $FssFFFFx: x is TopOfROM*/
	char						siStatusFlags;					/*bit 0 - card is changed*/
	short						siTOConst;						/*Time Out C for BusErr*/
	char						siReserved[2];					/*reserved*/
	Ptr							siROMAddr;						/* addr of top of ROM */
	char						siSlot;							/* slot number */
	char						siPadding[3];					/* reserved */
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct SInfoRecord SInfoRecord;

typedef SInfoRecord *SInfoRecPtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct SDMRecord {
	ProcPtr						sdBEVSave;						/*Save old BusErr vector*/
	ProcPtr						sdBusErrProc;					/*Go here to determine if it is a BusErr*/
	ProcPtr						sdErrorEntry;					/*Go here if BusErrProc finds real BusErr*/
	long						sdReserved;						/*Reserved*/
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct SDMRecord SDMRecord;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct FHeaderRec {
	long						fhDirOffset;					/*offset to directory*/
	long						fhLength;						/*length of ROM*/
	long						fhCRC;							/*CRC*/
	char						fhROMRev;						/*revision of ROM*/
	char						fhFormat;						/*format - 2*/
	long						fhTstPat;						/*test pattern*/
	char						fhReserved;						/*reserved*/
	char						fhByteLanes;					/*ByteLanes*/
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct FHeaderRec FHeaderRec;

typedef FHeaderRec *FHeaderRecPtr;

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct SEBlock {
	unsigned char				seSlot;							/*Slot number.*/
	unsigned char				sesRsrcId;						/*sResource Id.*/
	short						seStatus;						/*Status of code executed by sExec.*/
	unsigned char				seFlags;						/*Flags*/
	unsigned char				seFiller0;						/*Filler, must be SignedByte to align on odd boundry*/
	unsigned char				seFiller1;						/*Filler*/
	unsigned char				seFiller2;						/*Filler*/
	long						seResult;						/*Result of sLoad.*/
	long						seIOFileName;					/*Pointer to IOFile name.*/
	unsigned char				seDevice;						/*Which device to read from.*/
	unsigned char				sePartition;					/*The partition.*/
	unsigned char				seOSType;						/*Type of OS.*/
	unsigned char				seReserved;						/*Reserved field.*/
	unsigned char				seRefNum;						/*RefNum of the driver.*/
	unsigned char				seNumDevices;					/* Number of devices to load.*/
	unsigned char				seBootState;					/*State of StartBoot code.*/
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct SEBlock SEBlock;

#ifdef __cplusplus
extern "C" {
#endif


/*  Principle  */


#if USES68KINLINES
#pragma parameter __D0 SReadByte(__A0)
#endif
extern pascal OSErr SReadByte(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7000, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SReadWord(__A0)
#endif
extern pascal OSErr SReadWord(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7001, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SReadLong(__A0)
#endif
extern pascal OSErr SReadLong(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7002, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SGetCString(__A0)
#endif
extern pascal OSErr SGetCString(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7003, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SGetBlock(__A0)
#endif
extern pascal OSErr SGetBlock(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7005, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SFindStruct(__A0)
#endif
extern pascal OSErr SFindStruct(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7006, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SReadStruct(__A0)
#endif
extern pascal OSErr SReadStruct(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7007, 0xA06E);

/*  Special  */


#if USES68KINLINES
#pragma parameter __D0 SReadInfo(__A0)
#endif
extern pascal OSErr SReadInfo(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7010, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SReadPRAMRec(__A0)
#endif
extern pascal OSErr SReadPRAMRec(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7011, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SPutPRAMRec(__A0)
#endif
extern pascal OSErr SPutPRAMRec(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7012, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SReadFHeader(__A0)
#endif
extern pascal OSErr SReadFHeader(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7013, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SNextSRsrc(__A0)
#endif
extern pascal OSErr SNextSRsrc(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7014, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SNextTypeSRsrc(__A0)
#endif
extern pascal OSErr SNextTypeSRsrc(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7015, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SRsrcInfo(__A0)
#endif
extern pascal OSErr SRsrcInfo(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7016, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SCkCardStat(__A0)
#endif
extern pascal OSErr SCkCardStat(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7018, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SReadDrvrName(__A0)
#endif
extern pascal OSErr SReadDrvrName(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7019, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SFindDevBase(__A0)
#endif
extern pascal OSErr SFindDevBase(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x701B, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SFindBigDevBase(__A0)
#endif
extern pascal OSErr SFindBigDevBase(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x701C, 0xA06E);

/*  Advanced  */


#if USES68KINLINES
#pragma parameter __D0 InitSDeclMgr(__A0)
#endif
extern pascal OSErr InitSDeclMgr(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7020, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SPrimaryInit(__A0)
#endif
extern pascal OSErr SPrimaryInit(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7021, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SCardChanged(__A0)
#endif
extern pascal OSErr SCardChanged(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7022, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SExec(__A0)
#endif
extern pascal OSErr SExec(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7023, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SOffsetData(__A0)
#endif
extern pascal OSErr SOffsetData(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7024, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SInitPRAMRecs(__A0)
#endif
extern pascal OSErr SInitPRAMRecs(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7025, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SReadPBSize(__A0)
#endif
extern pascal OSErr SReadPBSize(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7026, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SCalcStep(__A0)
#endif
extern pascal OSErr SCalcStep(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7028, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SInitSRsrcTable(__A0)
#endif
extern pascal OSErr SInitSRsrcTable(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7029, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SSearchSRT(__A0)
#endif
extern pascal OSErr SSearchSRT(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x702A, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SUpdateSRT(__A0)
#endif
extern pascal OSErr SUpdateSRT(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x702B, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SCalcSPointer(__A0)
#endif
extern pascal OSErr SCalcSPointer(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x702C, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SGetDriver(__A0)
#endif
extern pascal OSErr SGetDriver(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x702D, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SPtrToSlot(__A0)
#endif
extern pascal OSErr SPtrToSlot(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x702E, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SFindSInfoRecPtr(__A0)
#endif
extern pascal OSErr SFindSInfoRecPtr(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x702F, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SFindSRsrcPtr(__A0)
#endif
extern pascal OSErr SFindSRsrcPtr(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7030, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SDeleteSRTRec(__A0)
#endif
extern pascal OSErr SDeleteSRTRec(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7031, 0xA06E);
extern pascal OSErr OpenSlot(ParmBlkPtr paramBlock, Boolean async);

#if USES68KINLINES
#pragma parameter __D0 OpenSlotSync(__A0)
#endif
extern pascal OSErr OpenSlotSync(ParmBlkPtr paramBlock)
 ONEWORDINLINE(0xA200);

#if USES68KINLINES
#pragma parameter __D0 OpenSlotAsync(__A0)
#endif
extern pascal OSErr OpenSlotAsync(ParmBlkPtr paramBlock)
 ONEWORDINLINE(0xA600);

/*  Device Manager Slot Support  */


#if USES68KINLINES
#pragma parameter __D0 SIntInstall(__A0, __D0)
#endif
extern pascal OSErr SIntInstall(SQElemPtr sIntQElemPtr, short theSlot)
 ONEWORDINLINE(0xA075);

#if USES68KINLINES
#pragma parameter __D0 SIntRemove(__A0, __D0)
#endif
extern pascal OSErr SIntRemove(SQElemPtr sIntQElemPtr, short theSlot)
 ONEWORDINLINE(0xA076);

#if USES68KINLINES
#pragma parameter __D0 SVersion(__A0)
#endif
extern pascal OSErr SVersion(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7008, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SetSRsrcState(__A0)
#endif
extern pascal OSErr SetSRsrcState(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x7009, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 InsertSRTRec(__A0)
#endif
extern pascal OSErr InsertSRTRec(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x700A, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SGetSRsrc(__A0)
#endif
extern pascal OSErr SGetSRsrc(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x700B, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SGetTypeSRsrc(__A0)
#endif
extern pascal OSErr SGetTypeSRsrc(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x700C, 0xA06E);

#if USES68KINLINES
#pragma parameter __D0 SGetSRsrcPtr(__A0)
#endif
extern pascal OSErr SGetSRsrcPtr(SpBlockPtr spBlkPtr)
 TWOWORDINLINE(0x701D, 0xA06E);
#ifdef __cplusplus
}
#endif

#endif

