/*
	File:		AEObjects.h

	Copyright:	© 1984-1993 by Apple Computer, Inc., all rights reserved.

	WARNING
	This file was auto generated by the interfacer tool. Modifications
	must be made to the master file.

*/

#ifndef __AEOBJECTS__
#define __AEOBJECTS__

#ifndef __MEMORY__
#include <Memory.h>
/*	#include <Types.h>											*/
/*		#include <ConditionalMacros.h>							*/
/*		#include <MixedMode.h>									*/
/*			#include <Traps.h>									*/
#endif

#ifndef __OSUTILS__
#include <OSUtils.h>
#endif

#ifndef __EVENTS__
#include <Events.h>
/*	#include <Quickdraw.h>										*/
/*		#include <QuickdrawText.h>								*/
/*			#include <IntlResources.h>							*/
#endif

#ifndef __EPPC__
#include <EPPC.h>
/*	#include <PPCToolBox.h>										*/
/*		#include <AppleTalk.h>									*/
/*	#include <Processes.h>										*/
/*		#include <Files.h>										*/
/*			#include <SegLoad.h>								*/
#endif

#ifndef __APPLEEVENTS__
#include <AppleEvents.h>
/*	#include <Notification.h>									*/
#endif

#ifdef __cplusplus
extern "C" {
#endif

enum  {
	gestaltObjectSupportLibraryInSystem = 1,
	gestaltObjectSupportLibraryPowerPCSupport = 2
};


/****	LOGICAL OPERATOR CONSTANTS	****/

enum  {
	kAEAND						= 0x414e4420,					//  'AND '  //
	kAEOR						= 0x4f522020,					//  'OR  '  //
	kAENOT						= 0x4e4f5420,					//  'NOT '  //
/****	ABSOLUTE ORDINAL CONSTANTS	****/
	kAEFirst					= 0x66697273,					//  'firs'  //
	kAELast						= 0x6c617374,					//  'last'  //
	kAEMiddle					= 0x6d696464,					//  'midd'  //
	kAEAny						= 0x616e7920,					//  'any '  //
	kAEAll						= 0x616c6c20,					//  'all '  //
/****	RELATIVE ORDINAL CONSTANTS	****/
	kAENext						= 0x6e657874,					//  'next'  //
	kAEPrevious					= 0x70726576,					//  'prev'  //
/****	KEYWORD CONSTANT 	****/
	keyAECompOperator			= 0x72656c6f,					//  'relo'  //
	keyAELogicalTerms			= 0x7465726d,					//  'term'  //
	keyAELogicalOperator		= 0x6c6f6763,					//  'logc'  //
	keyAEObject1				= 0x6f626a31,					//  'obj1'  //
	keyAEObject2				= 0x6f626a32,					//  'obj2'  //
/*	... for Keywords for getting fields out of object specifier records. */
	keyAEDesiredClass			= 0x77616e74,					//  'want'  //
	keyAEContainer				= 0x66726f6d,					//  'from'  //
	keyAEKeyForm				= 0x666f726d,					//  'form'  //
	keyAEKeyData				= 0x73656c64					//  'seld'  //
};

enum  {
/*	... for Keywords for getting fields out of Range specifier records. */
	keyAERangeStart				= 0x73746172,					//  'star'  //
	keyAERangeStop				= 0x73746f70,					//  'stop'  //
/*	... special handler selectors for OSL Callbacks. */
	keyDisposeTokenProc			= 0x78746f6b,					//  'xtok'  //
	keyAECompareProc			= 0x636d7072,					//  'cmpr'  //
	keyAECountProc				= 0x636f6e74,					//  'cont'  //
	keyAEMarkTokenProc			= 0x6d6b6964,					//  'mkid'  //
	keyAEMarkProc				= 0x6d61726b,					//  'mark'  //
	keyAEAdjustMarksProc		= 0x61646a6d,					//  'adjm'  //
	keyAEGetErrDescProc			= 0x696e6463					//  'indc'  //
};


/****	VALUE and TYPE CONSTANTS	****/

enum  {
/*	... possible values for the keyAEKeyForm field of an object specifier. */
	formAbsolutePosition		= 0x696e6478,					//  'indx'  //
	formRelativePosition		= 0x72656c65,					//  'rele'  //
	formTest					= 0x74657374,					//  'test'  //
	formRange					= 0x72616e67,					//  'rang'  //
	formPropertyID				= 0x70726f70,					//  'prop'  //
	formName					= 0x6e616d65,					//  'name'  //
/*	... relevant types (some of these are often pared with forms above). */
	typeObjectSpecifier			= 0x6f626a20,					//  'obj '  //
	typeObjectBeingExamined		= 0x65786d6e,					//  'exmn'  //
	typeCurrentContainer		= 0x63636e74,					//  'ccnt'  //
	typeToken					= 0x746f6b65,					//  'toke'  //
	typeRelativeDescriptor		= 0x72656c20,					//  'rel '  //
	typeAbsoluteOrdinal			= 0x6162736f,					//  'abso'  //
	typeIndexDescriptor			= 0x696e6465,					//  'inde'  //
	typeRangeDescriptor			= 0x72616e67,					//  'rang'  //
	typeLogicalDescriptor		= 0x6c6f6769,					//  'logi'  //
	typeCompDescriptor			= 0x636d7064					//  'cmpd'  //
};


/* Possible values for flags parameter to AEResolve.  They're additive */

enum  {
	kAEIDoMinimum				= 0x0000,
	kAEIDoWhose					= 0x0001,
	kAEIDoMarking				= 0x0004
};


/**** SPECIAL CONSTANTS FOR CUSTOM WHOSE-CLAUSE RESOLUTION */

enum  {
	typeWhoseDescriptor			= 0x77686f73,					//  'whos'  //
	formWhose					= 0x77686f73,					//  'whos'  //
	typeWhoseRange				= 0x77726e67,					//  'wrng'  //
	keyAEWhoseRangeStart		= 0x77737472,					//  'wstr'  //
	keyAEWhoseRangeStop			= 0x77737470,					//  'wstp'  //
	keyAEIndex					= 0x6b696478,					//  'kidx'  //
	keyAETest					= 0x6b747374					//  'ktst'  //
};


/****	OSL ERROR CODES			****/

enum  {
	errAEImpossibleRange		= -1720,						/* A range like 3rd to 2nd, or 1st to all. */
	errAEWrongNumberArgs		= -1721,						/* Logical op kAENOT used with other than 1 term */
	errAEAccessorNotFound		= -1723,						/* Accessor proc matching wantClass and containerType
												...or wildcards not found */
	errAENoSuchLogical			= -1725,						/* Something other than AND, OR, or NOT */
	errAEBadTestKey				= -1726,						/* Test is neither typeLogicalDescriptor
												...nor typeCompDescriptor */
	errAENotAnObjSpec			= -1727,						/* Param to AEResolve not of type 'obj ' */
	errAENoSuchObject			= -1728,						/* e.g.,: specifier asked for the 3rd, but there are only 2.
												...Basically, this indicates a run-time resolution error. */
	errAENegativeCount			= -1729,						/* CountProc returned negative value */
	errAEEmptyListContainer		= -1730							/* Attempt to pass empty list as container to accessor */
};


/* used for rewriting tokens in place of 'ccnt' descriptors			*/


/* This record is only of interest to those who, when they...		*/


/* ...get ranges as key data in their accessor procs, choose		*/


/* ...to resolve them manually rather than call AEResolve again.	*/

#if defined(powerc) || defined (__powerc)
#pragma options align=mac68k
#endif
struct ccntTokenRecord {
	DescType					tokenClass;
	AEDesc						token;
};
#if defined(powerc) || defined(__powerc)
#pragma options align=reset
#endif

typedef struct ccntTokenRecord ccntTokenRecord, *ccntTokenRecPtr, **ccntTokenRecHandle;

typedef AEDesc *DescPtr, **DescHandle;


/* typedefs providing type checking for procedure pointers */

typedef pascal OSErr (*OSLAccessorProcPtr)(DescType desiredClass, const AEDesc *container, DescType containerClass, DescType form, const AEDesc *selectionData, AEDesc *value, long accessorRefcon);

enum {
	uppOSLAccessorProcInfo = kPascalStackBased
		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))
		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(DescType)))
		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(AEDesc*)))
		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(DescType)))
		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(DescType)))
		 | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(AEDesc*)))
		 | STACK_ROUTINE_PARAMETER(6, SIZE_CODE(sizeof(AEDesc*)))
		 | STACK_ROUTINE_PARAMETER(7, SIZE_CODE(sizeof(long)))
};

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr OSLAccessorUPP;

#define CallOSLAccessorProc(userRoutine, desiredClass, container, containerClass, form, selectionData, value, accessorRefcon)		\
		CallUniversalProc((UniversalProcPtr)userRoutine, uppOSLAccessorProcInfo, desiredClass, container, containerClass, form, selectionData, value, accessorRefcon)
#define NewOSLAccessorProc(userRoutine)		\
		(OSLAccessorUPP) NewRoutineDescriptor((ProcPtr)userRoutine, uppOSLAccessorProcInfo, GetCurrentISA())
#else
typedef OSLAccessorProcPtr OSLAccessorUPP;

#define CallOSLAccessorProc(userRoutine, desiredClass, container, containerClass, form, selectionData, value, accessorRefcon)		\
		(*userRoutine)(desiredClass, container, containerClass, form, selectionData, value, accessorRefcon)
#define NewOSLAccessorProc(userRoutine)		\
		(OSLAccessorUPP)(userRoutine)
#endif

typedef pascal OSErr (*OSLCompareProcPtr)(DescType oper, const AEDesc *obj1, const AEDesc *obj2, Boolean *result);

enum {
	uppOSLCompareProcInfo = kPascalStackBased
		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))
		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(DescType)))
		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(AEDesc*)))
		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(AEDesc*)))
		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(Boolean*)))
};

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr OSLCompareUPP;

#define CallOSLCompareProc(userRoutine, oper, obj1, obj2, result)		\
		CallUniversalProc((UniversalProcPtr)userRoutine, uppOSLCompareProcInfo, oper, obj1, obj2, result)
#define NewOSLCompareProc(userRoutine)		\
		(OSLCompareUPP) NewRoutineDescriptor((ProcPtr)userRoutine, uppOSLCompareProcInfo, GetCurrentISA())
#else
typedef OSLCompareProcPtr OSLCompareUPP;

#define CallOSLCompareProc(userRoutine, oper, obj1, obj2, result)		\
		(*userRoutine)(oper, obj1, obj2, result)
#define NewOSLCompareProc(userRoutine)		\
		(OSLCompareUPP)(userRoutine)
#endif

typedef pascal OSErr (*OSLCountProcPtr)(DescType desiredType, DescType containerClass, const AEDesc *container, long *result);

enum {
	uppOSLCountProcInfo = kPascalStackBased
		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))
		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(DescType)))
		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(DescType)))
		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(AEDesc*)))
		 | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(long*)))
};

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr OSLCountUPP;

#define CallOSLCountProc(userRoutine, desiredType, containerClass, container, result)		\
		CallUniversalProc((UniversalProcPtr)userRoutine, uppOSLCountProcInfo, desiredType, containerClass, container, result)
#define NewOSLCountProc(userRoutine)		\
		(OSLCountUPP) NewRoutineDescriptor((ProcPtr)userRoutine, uppOSLCountProcInfo, GetCurrentISA())
#else
typedef OSLCountProcPtr OSLCountUPP;

#define CallOSLCountProc(userRoutine, desiredType, containerClass, container, result)		\
		(*userRoutine)(desiredType, containerClass, container, result)
#define NewOSLCountProc(userRoutine)		\
		(OSLCountUPP)(userRoutine)
#endif

typedef pascal OSErr (*OSLDisposeTokenProcPtr)(AEDesc *unneededToken);

enum {
	uppOSLDisposeTokenProcInfo = kPascalStackBased
		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))
		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(AEDesc*)))
};

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr OSLDisposeTokenUPP;

#define CallOSLDisposeTokenProc(userRoutine, unneededToken)		\
		CallUniversalProc((UniversalProcPtr)userRoutine, uppOSLDisposeTokenProcInfo, unneededToken)
#define NewOSLDisposeTokenProc(userRoutine)		\
		(OSLDisposeTokenUPP) NewRoutineDescriptor((ProcPtr)userRoutine, uppOSLDisposeTokenProcInfo, GetCurrentISA())
#else
typedef OSLDisposeTokenProcPtr OSLDisposeTokenUPP;

#define CallOSLDisposeTokenProc(userRoutine, unneededToken)		\
		(*userRoutine)(unneededToken)
#define NewOSLDisposeTokenProc(userRoutine)		\
		(OSLDisposeTokenUPP)(userRoutine)
#endif

typedef pascal OSErr (*OSLGetMarkTokenProcPtr)(const AEDesc *dContainerToken, DescType containerClass, AEDesc *result);

enum {
	uppOSLGetMarkTokenProcInfo = kPascalStackBased
		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))
		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(AEDesc*)))
		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(DescType)))
		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(AEDesc*)))
};

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr OSLGetMarkTokenUPP;

#define CallOSLGetMarkTokenProc(userRoutine, dContainerToken, containerClass, result)		\
		CallUniversalProc((UniversalProcPtr)userRoutine, uppOSLGetMarkTokenProcInfo, dContainerToken, containerClass, result)
#define NewOSLGetMarkTokenProc(userRoutine)		\
		(OSLGetMarkTokenUPP) NewRoutineDescriptor((ProcPtr)userRoutine, uppOSLGetMarkTokenProcInfo, GetCurrentISA())
#else
typedef OSLGetMarkTokenProcPtr OSLGetMarkTokenUPP;

#define CallOSLGetMarkTokenProc(userRoutine, dContainerToken, containerClass, result)		\
		(*userRoutine)(dContainerToken, containerClass, result)
#define NewOSLGetMarkTokenProc(userRoutine)		\
		(OSLGetMarkTokenUPP)(userRoutine)
#endif

typedef pascal OSErr (*OSLGetErrDescProcPtr)(DescPtr *appDescPtr);

enum {
	uppOSLGetErrDescProcInfo = kPascalStackBased
		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))
		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(DescPtr*)))
};

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr OSLGetErrDescUPP;

#define CallOSLGetErrDescProc(userRoutine, appDescPtr)		\
		CallUniversalProc((UniversalProcPtr)userRoutine, uppOSLGetErrDescProcInfo, appDescPtr)
#define NewOSLGetErrDescProc(userRoutine)		\
		(OSLGetErrDescUPP) NewRoutineDescriptor((ProcPtr)userRoutine, uppOSLGetErrDescProcInfo, GetCurrentISA())
#else
typedef OSLGetErrDescProcPtr OSLGetErrDescUPP;

#define CallOSLGetErrDescProc(userRoutine, appDescPtr)		\
		(*userRoutine)(appDescPtr)
#define NewOSLGetErrDescProc(userRoutine)		\
		(OSLGetErrDescUPP)(userRoutine)
#endif

typedef pascal OSErr (*OSLMarkProcPtr)(const AEDesc *dToken, const AEDesc *markToken, long index);

enum {
	uppOSLMarkProcInfo = kPascalStackBased
		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))
		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(AEDesc*)))
		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(AEDesc*)))
		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(long)))
};

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr OSLMarkUPP;

#define CallOSLMarkProc(userRoutine, dToken, markToken, index)		\
		CallUniversalProc((UniversalProcPtr)userRoutine, uppOSLMarkProcInfo, dToken, markToken, index)
#define NewOSLMarkProc(userRoutine)		\
		(OSLMarkUPP) NewRoutineDescriptor((ProcPtr)userRoutine, uppOSLMarkProcInfo, GetCurrentISA())
#else
typedef OSLMarkProcPtr OSLMarkUPP;

#define CallOSLMarkProc(userRoutine, dToken, markToken, index)		\
		(*userRoutine)(dToken, markToken, index)
#define NewOSLMarkProc(userRoutine)		\
		(OSLMarkUPP)(userRoutine)
#endif

typedef pascal OSErr (*OSLAdjustMarksProcPtr)(long newStart, long newStop, const AEDesc *markToken);

enum {
	uppOSLAdjustMarksProcInfo = kPascalStackBased
		 | RESULT_SIZE(SIZE_CODE(sizeof(OSErr)))
		 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(long)))
		 | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(long)))
		 | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(AEDesc*)))
};

#if USESROUTINEDESCRIPTORS
typedef UniversalProcPtr OSLAdjustMarksUPP;

#define CallOSLAdjustMarksProc(userRoutine, newStart, newStop, markToken)		\
		CallUniversalProc((UniversalProcPtr)userRoutine, uppOSLAdjustMarksProcInfo, newStart, newStop, markToken)
#define NewOSLAdjustMarksProc(userRoutine)		\
		(OSLAdjustMarksUPP) NewRoutineDescriptor((ProcPtr)userRoutine, uppOSLAdjustMarksProcInfo, GetCurrentISA())
#else
typedef OSLAdjustMarksProcPtr OSLAdjustMarksUPP;

#define CallOSLAdjustMarksProc(userRoutine, newStart, newStop, markToken)		\
		(*userRoutine)(newStart, newStop, markToken)
#define NewOSLAdjustMarksProc(userRoutine)		\
		(OSLAdjustMarksUPP)(userRoutine)
#endif


/*——————————————————————————————— PUBLIC PROCEDURES —————————————————————————————————*/

extern pascal OSErr AEObjectInit();

/* Not done by inline, but by direct linking into code.  It sets up the pack
  such that further calls can be via inline */

extern pascal OSErr AESetObjectCallbacks(OSLCompareUPP myCompareProc, OSLCountUPP myCountProc, OSLDisposeTokenUPP myDisposeTokenProc, OSLGetMarkTokenUPP myGetMarkTokenProc, OSLMarkUPP myMarkProc, OSLAdjustMarksUPP myAdjustMarksProc, OSLGetErrDescUPP myGetErrDescProcPtr)
 THREEWORDINLINE(0x303C, 0x0E35, 0xA816);
extern pascal OSErr AEResolve(const AEDesc *objectSpecifier, short callbackFlags, AEDesc *theToken)
 THREEWORDINLINE(0x303C, 0x0536, 0xA816);
extern pascal OSErr AEInstallObjectAccessor(DescType desiredClass, DescType containerType, OSLAccessorUPP theAccessor, long accessorRefcon, Boolean isSysHandler)
 THREEWORDINLINE(0x303C, 0x0937, 0xA816);
extern pascal OSErr AERemoveObjectAccessor(DescType desiredClass, DescType containerType, OSLAccessorUPP theAccessor, Boolean isSysHandler)
 THREEWORDINLINE(0x303C, 0x0738, 0xA816);
extern pascal OSErr AEGetObjectAccessor(DescType desiredClass, DescType containerType, OSLAccessorUPP *accessor, long *accessorRefcon, Boolean isSysHandler)
 THREEWORDINLINE(0x303C, 0x0939, 0xA816);
extern pascal OSErr AEDisposeToken(AEDesc *theToken)
 THREEWORDINLINE(0x303C, 0x023A, 0xA816);
extern pascal OSErr AECallObjectAccessor(DescType desiredClass, const AEDesc *containerToken, DescType containerClass, DescType keyForm, const AEDesc *keyData, AEDesc *token)
 THREEWORDINLINE(0x303C, 0x0C3B, 0xA816);
#ifdef __cplusplus
}
#endif

#endif

